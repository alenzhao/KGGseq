/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package org.cobi.kggseq;

import cern.colt.list.IntArrayList;
import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import java.awt.Toolkit;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.apache.log4j.Logger;
import static org.cobi.kggseq.Constants.VAR_FEATURE_NAMES;
import org.cobi.kggseq.controller.GeneAnnotator;
import org.cobi.kggseq.controller.GeneRegionParser;
import org.cobi.kggseq.controller.LinkageFileParser;
import org.cobi.kggseq.controller.SimpleFormatParser;
import org.cobi.kggseq.controller.VCFParser;
import org.cobi.kggseq.controller.VariantAnnotator;
import org.cobi.kggseq.controller.VariantFilter;
import org.cobi.kggseq.entity.AnnotationSummarySet;
import org.cobi.kggseq.entity.Chromosome;
import org.cobi.kggseq.entity.CombOrderComparator;
import org.cobi.kggseq.entity.CombOrders;
import org.cobi.kggseq.entity.FiltrationSummarySet;
import org.cobi.kggseq.entity.Genome;
import org.cobi.kggseq.entity.Individual;
import org.cobi.kggseq.entity.IntSet;
import org.cobi.kggseq.entity.ReferenceGenome;
import org.cobi.kggseq.entity.RegressionParams;
import org.cobi.kggseq.entity.VCFBitGtySetting;
import org.cobi.kggseq.entity.Variant;
import org.cobi.randomforests.MyRandomForest;
import org.cobi.randomforests.MyRandomTree;
import org.cobi.util.file.LocalFileFunc;
import org.cobi.util.net.NetUtils;
import org.cobi.util.text.LocalExcelFile;
import org.cobi.util.text.LocalFile;
import org.cobi.util.text.Util;
import org.objenesis.strategy.StdInstantiatorStrategy;
import org.rosuda.REngine.Rserve.RConnection;
import org.rosuda.REngine.Rserve.RserveException;

/**
 *
 * @author mxli
 */
public class CUIApp implements Constants {

    Options options;
    private static final Logger LOG = Logger.getLogger(CUIApp.class);

    public CUIApp(Options options) throws Exception {
        this.options = options;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        String headInfor = "@----------------------------------------------------------@\n" + "|        " + PREL + "        |     v" + PVERSION + "     |   " + PDATE + "     |\n"
                + "|----------------------------------------------------------|\n" + "|  (C) 2011 Miaoxin Li,  limx54@yahoo.com                  |\n"
                + "|----------------------------------------------------------|\n" + "|  For documentation, citation & bug-report instructions:  |\n"
                + "|        http://statgenpro.psychiatry.hku.hk/kggseq        |\n" + "@----------------------------------------------------------@";

        long time = System.nanoTime();
        Options option = new Options();
        try {
            if (args.length == 1 && !args[0].startsWith("--")) {
                option.readOptions(args[0]);
            } else if (args.length >= 1) {
                option.readOptions(args);
            } else {
                System.out.println("Usage: java -Xmx1g -jar kggseq.jar param.txt\n Or:  java -Xmx1g -jar kggseq.jar [options] ...");
                return;
            }
            String param = option.parseOptions();
            // System.out.println(headInfor);
            LOG.info("\n" + headInfor + "\nEffective settings :\n" + param);

            GlobalManager.initiateVariables(option.refGenomeVersion, option.resourceFolder, option.maxGtyAlleleNum);
            if (option.needRconnection) {
                RConnection rcon = null;
                try {
                    rcon = new RConnection();
                } catch (RserveException ex) {
                    if (ex.getMessage().contains("Cannot connect")) {

                        // System.out.println(ex.getMessage() + "\t" +
                        // ex.getRequestReturnCode() + "\t" +
                        // ex.getRequestErrorDescription());
                        String infor = "Please open your R and type the following commands to allow kggseq to use it:\npack=\"Rserve\";\n"
                                + "if (!require(pack,character.only = TRUE))   { install.packages(pack,dep=TRUE,repos=\'http://cran.us.r-project.org\');   if(!require(pack,character.only = TRUE)) stop(\"Package not found\")   }\n"
                                + "library(\"Rserve\");\nRserve(debug = FALSE, port = 6311, args = NULL)\n";
                        LOG.fatal(infor);
                        TimeUnit.SECONDS.sleep(1);
                    }
                    System.exit(1);
                } finally {
                    if (rcon != null) {
                        rcon.close();
                    }
                }
            }
            if (!option.noLibCheck || !option.noResCheck) {
                GlobalManager.checkConnection();
            }
            if (!option.noLibCheck) {
                if (GlobalManager.isConnectInternet) {
                    if (NetUtils.checkLibFileVersion()) {
                        return;
                    }
                }
            }

            if (!option.noResCheck) {
                if (GlobalManager.isConnectInternet) {
                    NetUtils.checkLatestResource(option);
                }
            } else {
                if (GlobalManager.isConnectInternet) {
                    // must check avaible resources
                    NetUtils.checkResourceList(option);
                }
            }

            CUIApp main = new CUIApp(option);
            main.process();
            time = System.nanoTime() - time;
            time = time / 1000000000;
            long min = time / 60;
            long sec = time % 60;
            LOG.info("Elapsed time: " + min + " min. " + sec + " sec.");
            if (option.needLog) {
                String info = "The log information is save in " + option.outputFileName + ".log";
                System.out.println(info);
            }

            Toolkit.getDefaultToolkit().beep();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public void process() throws Exception {
        Genome uniqueGenome = null;
        Set<String> caseSet = null;
        Set<String> controlSet = null;
        Set<String> unkownSet = null;
        List<Individual> subjectList = new ArrayList<Individual>();
        List<IntSet>[] gtyCorrdiates = new List[STAND_CHROM_NAMES.length];
        for (byte i = 0; i < STAND_CHROM_NAMES.length; i++) {
            gtyCorrdiates[i] = new ArrayList<IntSet>();
        }

        boolean needGty = false;
        File finalFilteredInFile = null;
        IntArrayList allEffectIndivIDs = new IntArrayList();
        VCFParser vsParser = new VCFParser();
        try {
            if (options.inputFormat.endsWith("--vcf-file")) {
                // if pedigree file is specified options.indivPhenos will be
                // ignored
                if (options.pedFile != null) {
                    LinkageFileParser linkPedParser = new LinkageFileParser();

                    linkPedParser.readPedigreeOnly(options.pedFile, subjectList, options.useCompositeSubjectID);
                    caseSet = new HashSet<String>();
                    controlSet = new HashSet<String>();
                    unkownSet = new HashSet<String>();

                    for (Individual indiv : subjectList) {
                        if (indiv.getAffectedStatus() == 1) {
                            controlSet.add(indiv.getLabelInChip());
                        } else if (indiv.getAffectedStatus() == 2) {
                            caseSet.add(indiv.getLabelInChip());
                        } else {
                            unkownSet.add(indiv.getLabelInChip());
                        }
                    }

                } /*
                 * else if
                 * (options.genetModel.equals("--compound-heterozygosity")
                 * && options.pedFile == null) { throw new Exception(
                 * "Please sepcify the relationship of subjects  by \'--ped-file path/to/pedigree/file\' for compound heterozygosity model checking!"
                 * ); }
                 */ else if (options.indivPhenos != null) {
                    caseSet = new HashSet<String>();
                    controlSet = new HashSet<String>();
                    unkownSet = new HashSet<String>();
                    for (String indivID : options.indivPhenos) {
                        String label = indivID.substring(0, indivID.indexOf(':'));
                        String d = indivID.substring(indivID.indexOf(":") + 1);
                        Individual indiv = new Individual();
                        if (d.charAt(0) == '1') {
                            controlSet.add(label);
                        } else if (d.charAt(0) == '2') {
                            caseSet.add(label);
                        } else {
                            unkownSet.add(label);
                        }
                        indiv.setLabelInChip(label);
                        indiv.setFamilyID(label);
                        indiv.setIndividualID(label);
                        indiv.setDadID("0");
                        indiv.setMomID("0");
                        indiv.setAffectedStatus(d.charAt(0) - '0');
                        subjectList.add(indiv);
                    }
                }
                if (options.pedFile != null || options.indivPhenos != null) {
                    if (caseSet.isEmpty() && controlSet.isEmpty()) {
                        String infor = ("All subjects in phenotype or pedigree file have unknown disease status.\n"
                                + "    Please specify the clear disease status for AT LEAST one subject!!");
                        throw new Exception(infor);
                    }
                }

                if (options.mergeGtyDb != null && options.isPlinkPedOut || options.isPlinkBedOut || options.isBinaryGtyOut) {
                    needGty = true;
                } else if (options.sampleGtyHardFilterCode != null) {
                    for (int i = 0; i < 9; i++) {
                        if (options.sampleGtyHardFilterCode.contains(String.valueOf(i))) {
                            needGty = true;
                            break;
                        }
                    }
                } else if (options.ibsCheckCase >= 0 || options.homozygousRegionCase >= 0) {
                    needGty = true;
                } else if (options.doubleHitGenePhasedFilter || options.doubleHitGeneTriosFilter) {
                    needGty = true;
                }

                boolean needReadsInfor = false;
                // options.sampleVarHardFilterCode
                if (options.sampleGtyHardFilterCode != null && (options.sampleGtyHardFilterCode.contains("7") || options.sampleGtyHardFilterCode.contains("8"))) {
                    needReadsInfor = true;
                }

                // gtyCorrdiates used to keep the sequential order
                uniqueGenome = vsParser.readVariantGtyFilterOnly(options.outputFileName, options.threadNum, null, options.inputFileName, options.seqQual, options.minMappingQuality, options.maxStandBias,
                        options.maxFisherStandBias, options.maxGtyAlleleNum, options.gtyQual, options.minGtySeqDP, options.maxAltAlleleFracRefHom, options.minAltAlleleFractHet,
                        options.minAltAlleleFractAltHom, options.vcfFilterLabelsIn, options.minOBS, options.sampleMafOver, options.sampleMafLess, options.considerSNV, options.considerIndel,
                        options.gtySecPL, options.gtyBestGP, options.needProgressionIndicator, needGty, needReadsInfor, options.needGtyQual, false, subjectList, allEffectIndivIDs);

                /*
                 * if (!subjectMap.isEmpty()) { FileOutputStream objFOut =
                 * new FileOutputStream(outName + ".gty.obj");
                 * BufferedOutputStream objOBfs = new
                 * BufferedOutputStream(objFOut); ObjectOutputStream
                 * localObjOut = new ObjectOutputStream(objOBfs);
                 * 
                 * localObjOut.writeObject(subjectMap); localObjOut.flush();
                 * localObjOut.close(); objOBfs.flush(); objOBfs.close();
                 * objFOut.close(); }
                 */
            } else if (options.inputFormat.endsWith("--tmp-file")) {
                SimpleFormatParser pileParser = new SimpleFormatParser();
                uniqueGenome = pileParser.readCancerGenomeVariantFormat(options.outputFileName, options.inputFileName, options.needProgressionIndicator);
            } else if (options.inputFormat.endsWith("--no-gty-vcf-file")) {
                // gtyCorrdiates used to keep the sequential order
                uniqueGenome = vsParser.readVariantGtyFilterOnly(options.outputFileName, options.threadNum, null, options.inputFileName, options.seqQual, options.minMappingQuality, options.maxStandBias,
                        options.maxFisherStandBias, options.maxGtyAlleleNum, options.gtyQual, options.minGtySeqDP, options.maxAltAlleleFracRefHom, options.minAltAlleleFractHet,
                        options.minAltAlleleFractAltHom, options.vcfFilterLabelsIn, options.minOBS, options.sampleMafOver, options.sampleMafLess, options.considerSNV, options.considerIndel,
                        options.gtySecPL, options.gtyBestGP, options.needProgressionIndicator, needGty, false, options.needGtyQual, true, subjectList, allEffectIndivIDs);
            }

            //-----------------------Annotate variants on each chromsome-------------------------------
            VariantAnnotator varAnnoter = new VariantAnnotator();
            VariantFilter varFilter = new VariantFilter();
            FiltrationSummarySet minMissingQCFilter = new FiltrationSummarySet("missingQC", uniqueGenome.getVariantFeatureNum());
            minMissingQCFilter.initiateAMessage(0, "variants are ignored due to the number of heterozygous genotypes <" + options.minHetA
                    + " or that of alternative homozygous genotypes <" + options.minHomA + " in cases.");

            minMissingQCFilter.initiateAMessage(0, "variants are ignored due to the number of heterozygous genotypes <" + options.minHetU
                    + " or that of alternative homozygous genotypes <" + options.minHomU + " in controls.");
            minMissingQCFilter.initiateAMessage(0, "variants are ignored due to the number of non-null genotypes in cases <" + options.minOBSA + ".");
            minMissingQCFilter.initiateAMessage(0, "variants are ignored due to the number of non-null genotypes in controls <" + options.minOBSU + ".");
            minMissingQCFilter.initiateAMessage(0, "variant(s) are left after filtration according to minimal successful genotype calling rates in patients and healthy individuals.");

            String hardFilterModel = options.sampleGtyHardFilterCode;
            int filterNum = 6;
            boolean[] uniqueFilters = new boolean[2];
            boolean[] genotypeFilters = new boolean[filterNum];
            Arrays.fill(uniqueFilters, false);
            Arrays.fill(genotypeFilters, false);
            boolean filterByModel = false;
            FiltrationSummarySet inheritanceModelFilter = null;
            FiltrationSummarySet denovoModelFilter = null;
            FiltrationSummarySet doubleHitGeneModelFilter = null;
            FiltrationSummarySet somaticModelFilter = null;
            List<int[]> setSampleIDList = null;
            List<String> setSampleLabelList = new ArrayList<String>();
            String currentLine;

            if (options.sampleGtyHardFilterCode != null && options.sampleGtyHardFilterCode.length() > 0) {
                for (int i = 0; i < filterNum; i++) {
                    String[] cells = options.sampleGtyHardFilterCode.split(",");
                    for (int t = 0; t < cells.length; t++) {
                        int s = Integer.parseInt(cells[t]) - 1;
                        if (s < filterNum) {
                            genotypeFilters[s] = true;
                            filterByModel = true;
                        }
                    }
                }
            }

            if (filterByModel) {
                inheritanceModelFilter = new FiltrationSummarySet("InheritanceModel", uniqueGenome.getVariantFeatureNum());
                inheritanceModelFilter.initiateAMessage(0, "variants are ignored by genotype-based hard-filtering.");
                inheritanceModelFilter.initiateAMessage(0, "variant(s) are left after filtration according to inheritance mode at genotypes, " + hardFilterModel + "!");
            }

            if (options.sampleGtyHardFilterCode != null && (options.sampleGtyHardFilterCode.contains("7"))) {
                denovoModelFilter = new FiltrationSummarySet("DenovoModel", uniqueGenome.getVariantFeatureNum());
                setSampleIDList = new ArrayList<int[]>();
                varFilter.matchTrioSet(subjectList, setSampleIDList);
                if (subjectList.isEmpty()) {
                    String infor = "No recognizable trios! To detect de novo mutation, you have to set the parents-child relationsby the tag --ped-file path/to/file!";
                    throw new Exception(infor);
                }
                uniqueGenome.addVariantFeatureLabel("DenovoMutationEvent");
                denovoModelFilter.initiateAMessage(0, "variant(s) are left after filtration by denovo mutation!");
            }

            AnnotationSummarySet[] varaintDBHardFilterFiles = null;
            AnnotationSummarySet[] varaintDBFilterFiles = null;

            int dbFileSize = options.varaintDBLableHardList != null ? options.varaintDBLableHardList.size() : 0;
            if (dbFileSize > 0) {
                varaintDBHardFilterFiles = new AnnotationSummarySet[dbFileSize];
                for (int i = 0; i < dbFileSize; i++) {
                    String dbLabelName = options.varaintDBLableHardList.get(i);
                    varaintDBHardFilterFiles[i] = new AnnotationSummarySet(dbLabelName, LocalFileFunc.getBufferedReader(GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get(dbLabelName)), new StringBuilder(), 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                }
            }
            dbFileSize = options.varaintDBLableList != null ? options.varaintDBLableList.size() : 0;
            if (dbFileSize > 0) {
                varaintDBFilterFiles = new AnnotationSummarySet[dbFileSize];
                for (int i = 0; i < dbFileSize; i++) {
                    String dbLabelName = options.varaintDBLableList.get(i);
                    varaintDBFilterFiles[i] = new AnnotationSummarySet(dbLabelName, LocalFileFunc.getBufferedReader(GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get(dbLabelName)), new StringBuilder(), 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                    uniqueGenome.addVariantFeatureLabel("altFreq@" + dbLabelName);
                }
            }
            if (options.causingPredType == 2) {
                somaticModelFilter = new FiltrationSummarySet("SomaticModel", uniqueGenome.getVariantFeatureNum());
            }

            if (options.sampleGtyHardFilterCode != null && (options.sampleGtyHardFilterCode.contains("8"))) {
                // search somatic mutation between cancer tissue and non-cancer tissues
                if (options.indivPairs == null) {
                    String infor = "To detect somatic mutation, you have to set the tumor sample and non-tumor samples pairs by the tag --indiv-pair tumorIndivID1:normalIndivID1,tumorIndivID2:normalIndivID2";
                    throw new Exception(infor);
                }

                // search somatic mutation between cancer tissue and non-cancer tissues
                // match pairs                
                setSampleIDList = new ArrayList<int[]>();
                varFilter.matchTumorNontumorPair(options.indivPairs, subjectList, setSampleIDList, setSampleLabelList);
                if (setSampleIDList.isEmpty()) {
                    List<String> vcfInds = new ArrayList<String>();
                    List<String> pedIndivs = new ArrayList<String>();
                    for (String pair : options.indivPairs) {
                        String[] invdivs = pair.split(":");
                        vcfInds.add(invdivs[0]);
                        vcfInds.add(invdivs[1]);
                    }

                    for (int t = 0; t < subjectList.size(); t++) {
                        pedIndivs.add(subjectList.get(t).getLabelInChip());
                    }

                    String infor = "No recognizable matched Tumor<->Nontumor pairs!\n"
                            + ("The subject IDs in the specified VCF file(s), " + vcfInds.toString() + " are not indentical to those in the phenotype or pedigree file " + pedIndivs.toString() + "!!");
                    throw new Exception(infor);
                }
                somaticModelFilter.initiateAMessage(0, "variant(s) are left after filtration by somatic mutations!");
                uniqueGenome.addVariantFeatureLabel("SomaticMutationEvent");
                uniqueGenome.addVariantFeatureLabel("TNTRefAltRead,P,OR");
            }

            FiltrationSummarySet geneDBFilter = null;
            int[] variantsCounters = null;
            dbFileSize = options.geneDBLabels != null ? options.geneDBLabels.length : 0;
            ReferenceGenome[] referenceGenomes = null;
            int[] availableFeatureSizeForGeneDB = new int[dbFileSize];
            if (dbFileSize > 0) {
                geneDBFilter = new FiltrationSummarySet("Gene DB", uniqueGenome.getVariantFeatureNum());

                geneDBFilter.initiateAMessage(0, " variant(s) are left after filtering by gene features.");
                variantsCounters = new int[VAR_FEATURE_NAMES.length];
                Arrays.fill(variantsCounters, 0);
                referenceGenomes = new ReferenceGenome[dbFileSize];
                File domainFile = new File(GlobalManager.RESOURCE_PATH + "/UniprotDomain.txt.gz");
                GeneRegionParser grp = new GeneRegionParser();
                for (int i = 0; i < dbFileSize; i++) {
                    String geneDBLabel = options.geneDBLabels[i];
                    String dbFileName = options.PUBDB_FILE_MAP.get(geneDBLabel);

                    File idMapFile = null;
                    if (geneDBLabel.equals("gencode")) {
                        idMapFile = new File(GlobalManager.RESOURCE_PATH + "/UniprotEnsemblMap.tab.gz");
                        referenceGenomes[i] = grp.readRefGeneSeq(GlobalManager.RESOURCE_PATH + "/" + dbFileName, geneDBLabel, options.splicingDis, options.neargeneDis, domainFile, idMapFile);
                        uniqueGenome.setGencodeAnnot(true);
                        availableFeatureSizeForGeneDB[i] = uniqueGenome.getVariantFeatureNum();
                        uniqueGenome.addVariantFeatureLabel("UniProtFeatureForGEncode");
                    } else if (geneDBLabel.equals("refgene")) {
                        uniqueGenome.setRefSeqAnnot(true);
                        availableFeatureSizeForGeneDB[i] = uniqueGenome.getVariantFeatureNum();
                        uniqueGenome.addVariantFeatureLabel("UniProtFeatureForRefGene");
                        idMapFile = new File(GlobalManager.RESOURCE_PATH + "/UniprotRefSeqMap.tab.gz");
                        // unforturately the ucsc file rna fasta file
                        // are not always consistant with the ucsc
                        // chromsome fasta
                        // refGenome =
                        // grp.readRefGeneSeqUcsc(GlobalManager.RESOURCE_PATH
                        // + "/" + dbFileName,
                        // GlobalManager.RESOURCE_PATH + "/" +
                        // "refMrna.fa.gz", geneDBLabel,
                        // options.splicingDis, options.neargeneDis,
                        // domainFile, idMapFile);
                        referenceGenomes[i] = grp.readRefGeneSeq(GlobalManager.RESOURCE_PATH + "/" + dbFileName, geneDBLabel, options.splicingDis, options.neargeneDis, domainFile, idMapFile);
                    } else if (geneDBLabel.equals("ensembl")) {
                        idMapFile = new File(GlobalManager.RESOURCE_PATH + "/UniprotEnsemblMap.tab.gz");
                        referenceGenomes[i] = grp.readRefGeneSeq(GlobalManager.RESOURCE_PATH + "/" + dbFileName, geneDBLabel, options.splicingDis, options.neargeneDis, domainFile, idMapFile);
                        uniqueGenome.setEnsemblAnnot(true);
                        availableFeatureSizeForGeneDB[i] = uniqueGenome.getVariantFeatureNum();
                        uniqueGenome.addVariantFeatureLabel("UniProtFeatureForEnsembl");
                    } else if (geneDBLabel.equals("knowngene")) {
                        idMapFile = new File(GlobalManager.RESOURCE_PATH + "/UniprotUCSCKnownGeneMap.tab.gz");
                        referenceGenomes[i] = grp.readRefGeneSeq(GlobalManager.RESOURCE_PATH + "/" + dbFileName, geneDBLabel, options.splicingDis, options.neargeneDis, domainFile, idMapFile);
                        uniqueGenome.setKnownAnnot(true);
                        availableFeatureSizeForGeneDB[i] = uniqueGenome.getVariantFeatureNum();
                        uniqueGenome.addVariantFeatureLabel("UniProtFeatureForKnownGene");
                    }
                    referenceGenomes[i].setName(geneDBLabel);
                }
            }

            FiltrationSummarySet dbNSFPAnnot = null;
            FiltrationSummarySet dbNSFPPred = null;
            List<CombOrders> combOrderList = new ArrayList<CombOrders>();
            CombOrders fixedComb = null;
            MyRandomForest myRandomForest = null;
            int somatNumIndex = -1;
            int readInfoIndex = -1;
            // dbNSFP3.0
            int[] dbNSFP3ScoreIndexes = new int[]{5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18};
            int[] dbNSFP3PredicIndex = new int[]{19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31};
            if (!options.scoreDBLableList.isEmpty()) {
                for (String dbLabelName : options.scoreDBLableList) {
                    if (dbLabelName.equals("dbnsfp")) {
                        String dbFileName = options.PUBDB_FILE_MAP.get(dbLabelName);
                        String path = GlobalManager.RESOURCE_PATH + "/" + dbFileName + "Y.gz";
                        BufferedReader br = LocalFileFunc.getBufferedReader(path);
                        currentLine = br.readLine();
                        String[] cells = currentLine.split("\t");
                        br.close();

                        dbNSFPAnnot = new FiltrationSummarySet("dbNSFP", uniqueGenome.getVariantFeatureNum());
                        dbNSFPAnnot.initiateAMessage(0, "coding nonsynonymous variants are assigned functional prediction scores.");

                        for (int t = 0; t < dbNSFP3ScoreIndexes.length; t++) {
                            uniqueGenome.getScoreLabels().add(cells[dbNSFP3ScoreIndexes[t]]);
                        }
                        for (int t = 0; t < dbNSFP3PredicIndex.length; t++) {
                            uniqueGenome.addVariantFeatureLabel(cells[dbNSFP3PredicIndex[t]]);
                        }
                        if (options.causingPredType == 0) {
                            // MendelFilter
                            String logitParamFile = GlobalManager.RESOURCE_PATH + "/mendelcausalrare" + options.dbsnfpVersion + ".param.gz";
                            br = LocalFileFunc.getBufferedReader(logitParamFile);
                            String line = null;

                            CombOrderComparator coc = new CombOrderComparator();
                            // String[] names = {"SLR_test_statistic", "SIFT_score",
                            // "Polyphen2_HDIV_score", "Polyphen2_HVAR_score", "LRT_score",
                            // "MutationTaster_score", "MutationAssessor_score", "FATHMM_score",
                            // "GERP++_NR", "GERP++_RS", "phyloP", "29way_logOdds"};
                            boolean isFixed = false;
                            if (!options.predictExplanatoryVar.startsWith("all") && !options.predictExplanatoryVar.startsWith("best")) {
                                isFixed = true;
                            }
                            float aucCutoff = 0.85f;
                            while ((line = br.readLine()) != null) {
                                if (line.trim().length() == 0) {
                                    continue;
                                }
                                cells = line.split("\t");
                                RegressionParams rp = new RegressionParams();

                                String[] values = cells[1].split(";");
                                rp.coef = new double[values.length];
                                for (int i = 0; i < rp.coef.length; i++) {
                                    rp.coef[i] = Double.parseDouble(values[i]);
                                }
                                rp.sampleCase2CtrRatio = Double.parseDouble(cells[2]);
                                rp.optimalCutoff = Double.parseDouble(cells[3].split(";")[0]);
                                rp.truePositiveRate = Double.parseDouble(cells[3].split(";")[1]);
                                rp.trueNegativeRate = Double.parseDouble(cells[3].split(";")[2]);

                                CombOrders co = new CombOrders(cells[0], Double.parseDouble(cells[4]), rp);
                                if (isFixed) {
                                    if (cells[0].equals(options.predictExplanatoryVar)) {
                                        fixedComb = co;
                                        break;
                                    }
                                } else {
                                    if (co.auc < aucCutoff) {
                                        continue;
                                    }
                                    combOrderList.add(co);
                                }

                            }

                            br.close();
                            Collections.sort(combOrderList, coc);

                            uniqueGenome.addVariantFeatureLabel("DiseaseCausalProb_ExoVarTrainedModel");
                            uniqueGenome.addVariantFeatureLabel("IsRareDiseaseCausal_ExoVarTrainedModel");
                            uniqueGenome.addVariantFeatureLabel("BestCombinedTools:OptimalCutoff:TP:TN");
                            dbNSFPPred = new FiltrationSummarySet("dbNSFPMendelPred", uniqueGenome.getVariantFeatureNum());
                            dbNSFPPred.initiateAMessage(0, "variants (in");
                            dbNSFPPred.initiateAMessage(0, "genes) are predicted to be disease-causal;");
                            dbNSFPPred.initiateAMessage(0, "variants are predicted to be non-disease-causal according to the Logistic regression prediction model trained by ExoVar dataset (http://statgenpro.psychiatry.hku.hk/limx/kggseq/download/ExoVar.xls)");
                            dbNSFPPred.initiateAMessage(0, "variant(s) are left after filtered by the disease mutation prediction.");
                        } else if (options.causingPredType == 2) {
                            File fileName = new File(GlobalManager.RESOURCE_PATH + "/CancerRandomForests" + options.dbsnfpVersion + ".obj");
                            if (!fileName.exists()) {
                                throw new Exception("Cannot find data in hard disk!");
                            }
                            Kryo kryo = new Kryo();

                            kryo.setReferences(false);
                            kryo.setRegistrationRequired(false);
                            kryo.setInstantiatorStrategy(new StdInstantiatorStrategy());
                            //note: it seems the order of registered classes is very very important 
                            kryo.register(MyRandomTree[].class);
                            kryo.register(MyRandomTree.class);
                            kryo.register(MyRandomForest.class);

                            Input input = new Input(new FileInputStream(fileName), 1024 * 1024);

                            myRandomForest = (MyRandomForest) kryo.readObject(input, MyRandomForest.class);
                            input.close();

                            /*
                             FileInputStream objFIn = new FileInputStream(fileName);
                             BufferedInputStream objIBfs = new BufferedInputStream(objFIn);
                             ObjectInputStream localObjIn = new ObjectInputStream(objIBfs);
                             MyRandomForest myRandomForest = (MyRandomForest) localObjIn.readObject();
                             localObjIn.close();
                             objIBfs.close();
                             objFIn.close();
                             */
                            dbNSFPPred = new FiltrationSummarySet("dbNSFPCancerPred", uniqueGenome.getVariantFeatureNum());
                            dbNSFPPred.initiateAMessage(0, "variants (in");
                            dbNSFPPred.initiateAMessage(0, "genes) are predicted to be cancer-driver;");
                            dbNSFPPred.initiateAMessage(0, "variants are predicted to be non-cancer-driver according to a Random Forests prediction model trained by COSMIC dataset (http://cancer.sanger.ac.uk/cancergenome/projects/cosmic/).");
                            dbNSFPPred.initiateAMessage(0, "variant(s) are left after filtered by the cancer-driver mutation prediction.");

                            uniqueGenome.addVariantFeatureLabel("IsCancerDriver_COSMICTrainedModel");
                            uniqueGenome.addVariantFeatureLabel("RandomForestScore");

                            List<String> featureLabels = uniqueGenome.getVariantFeatureLabels();
                            for (int i = 0; i < featureLabels.size(); i++) {
                                if (featureLabels.get(i).equals("SomaticMutationEvent")) {
                                    somatNumIndex = i;
                                } else if (featureLabels.get(i).equals("TNTRefAltRead,P,OR")) {
                                    readInfoIndex = i;
                                }
                                if (somatNumIndex >= 0 && readInfoIndex >= 0) {
                                    break;
                                }
                            }
                            // special consideration for pileup files
                            if (somatNumIndex < 0) {
                                for (int i = 0; i < featureLabels.size(); i++) {
                                    if (featureLabels.get(i).equals("Comments")) {
                                        somatNumIndex = i;
                                        break;
                                    }
                                }
                            }

                            uniqueGenome.addGeneFeatureLabel("#NonsynonymousVar");
                            uniqueGenome.addGeneFeatureLabel("#SynonymousVar");
                            uniqueGenome.addGeneFeatureLabel("NonsynonymousReadsRatio");
                            uniqueGenome.addGeneFeatureLabel("SynonymousReadsRatio");
                            if (readInfoIndex > 0) {
                                uniqueGenome.addGeneFeatureLabel("ReadsInfor");
                            }
                        }
                    }
                }
            }
            
            AnnotationSummarySet dbScSNV = null;
            if (options.dbscSNVAnnote) {
                String dbLabelName = "dbscSNV";
                uniqueGenome.addVariantFeatureLabel("ada_score@dbScSNV" + dbLabelName);
                dbScSNV = new AnnotationSummarySet("dbscSNV", LocalFileFunc.getBufferedReader(GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get(dbLabelName)), new StringBuilder(), 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                //skip the head line
                dbScSNV.getBr().readLine();
            }

            Map<String, String> genePubMedID = new HashMap<String, String>();
            String fileName = "HgncGene.txt";
            File resourceFile = new File(GlobalManager.RESOURCE_PATH + "/" + fileName);
            Map<String, String[]> geneNamesMap = varAnnoter.readGeneNames(resourceFile.getCanonicalPath());
            List<String[]> hitDisCountsGenes = null;
            List<String[]> hitDisCounReads = null;
            List<Individual> sortedSubjectList = null;
            List<int[]> triosIDList = null;
            IntArrayList effectiveIndivIDsTrios = null;
            Set<String> caseDoubleHitGenes = null;
            Set<String> controlDoubleHitGenes = null;
            if (options.doubleHitGeneTriosFilter) {
                hitDisCountsGenes = new ArrayList<String[]>();
                hitDisCounReads = new ArrayList<String[]>();
                doubleHitGeneModelFilter = new FiltrationSummarySet("DoubleHitModel", uniqueGenome.getVariantFeatureNum());
                doubleHitGeneModelFilter.initiateAMessage(0, "variant(s) are left after filtered by the double-hit genes using parents' genotypes.");
                caseDoubleHitGenes = new HashSet<String>();
                controlDoubleHitGenes = new HashSet<String>();
                // cluster counts according to phentoypes
                int indivSize = subjectList.size();
                sortedSubjectList = new ArrayList<Individual>(indivSize);
                for (int t = 0; t < 3; t++) {
                    for (int j = 0; j < indivSize; j++) {
                        Individual mIndiv = subjectList.get(j);
                        if (mIndiv.getAffectedStatus() == t) {
                            sortedSubjectList.add(mIndiv);
                        }
                    }
                }

                triosIDList = new ArrayList<int[]>();
                varFilter.matchTrioSet(sortedSubjectList, triosIDList);
                if (triosIDList.isEmpty()) {
                    String infor = "No recognizable trios for double-hit gene checking!";
                    LOG.error(infor);
                    return;
                }
//prepare the output format

                List<String> headActual = new ArrayList<String>();
                headActual.add("Gene");
                headActual.add("PubMed");
                headActual.add("ExonLen");
                headActual.add("CaseSyno");
                headActual.add("CaseNonSyno");
                int effectiveIndivSize = 0;

                if (options.countAllPsudoControl) {
                    headActual.add("PseudoControlSyno");
                    headActual.add("PseudoControlNonSyno");
                    headActual.add("PValue");
                }

                List<String> headPhenotype = new ArrayList<String>();
                headPhenotype.add("Disease");
                headPhenotype.add(".");
                headPhenotype.add(".");
                headPhenotype.add(".");
                headPhenotype.add(".");
                if (options.countAllPsudoControl) {
                    headPhenotype.add(".");
                    headPhenotype.add(".");
                    headPhenotype.add(".");
                }

                effectiveIndivIDsTrios = new IntArrayList();
                int setSize = triosIDList.size();
                for (int j = 0; j < setSize; j++) {
                    Individual mIndiv = sortedSubjectList.get(triosIDList.get(j)[0]);
                    if (triosIDList.get(j)[0] < 0 || triosIDList.get(j)[1] < 0 || triosIDList.get(j)[2] < 0) {
                        continue;
                    }

                    effectiveIndivIDsTrios.add(j);
                    headActual.add(mIndiv.getLabelInChip());
                    headPhenotype.add(String.valueOf(mIndiv.getAffectedStatus()));
                    effectiveIndivSize++;
                }
                hitDisCountsGenes.add(headActual.toArray(new String[0]));
                hitDisCountsGenes.add(headPhenotype.toArray(new String[0]));
                hitDisCounReads.add(headActual.toArray(new String[0]));
                hitDisCounReads.add(headPhenotype.toArray(new String[0]));

                if (effectiveIndivSize == 0) {
                    String infor = "No valid trios for double-hit gene checking!";
                    LOG.warn(infor);
                    return;
                }
            }

            AnnotationSummarySet assGene = null;
            AnnotationSummarySet assVariant=null;
            if (options.needAnnotateGene) {
                String fileNameHg = "HgncGene.txt";
                File resourceFileHg = new File(GlobalManager.RESOURCE_PATH + "/" + fileNameHg);
                if (uniqueGenome.getGeneNum() > 0) {
                    uniqueGenome.addmRNAFeatureLabel("GeneDescription");
                    uniqueGenome.addmRNAFeatureLabel("Pseudogenes");
                    assGene=new AnnotationSummarySet(fileNameHg, LocalFileFunc.getBufferedReader(resourceFileHg.getCanonicalPath()), new StringBuilder(), 0, 0, 0, uniqueGenome.getmRNAFeatureNum());
                } else if (uniqueGenome.getVarNum() > 0) {
                    uniqueGenome.addVariantFeatureLabel("GeneDescription");
                    uniqueGenome.addVariantFeatureLabel("Pseudogenes");  
                    assVariant=new AnnotationSummarySet(fileNameHg, LocalFileFunc.getBufferedReader(resourceFileHg.getCanonicalPath()), new StringBuilder(), 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                }              
            }         
            
            
            
            
            
            
            
            File annovarFilteredInFile = null;
            BufferedWriter annovarFilteredInFileWriter = null;

            if (options.isANNOVAROut) {
                annovarFilteredInFile = new File(options.outputFileName + ".flt.annovar");
                annovarFilteredInFileWriter = new BufferedWriter(new FileWriter(annovarFilteredInFile));
            }
            BufferedWriter bwMapBed = null;

            int[] savedBinnaryBedVar = new int[2];
            savedBinnaryBedVar[0] = 0;
            savedBinnaryBedVar[1] = 0;
            RandomAccessFile rafBed = null;
            FileChannel fileChannelBed = null;
            if (options.isPlinkBedOut) {
                bwMapBed = new BufferedWriter(new FileWriter(options.outputFileName + ".bim"));
                BufferedWriter bwPed = new BufferedWriter(new FileWriter(options.outputFileName + ".fam"));
                for (Individual indiv : subjectList) {
                    if (indiv == null) {
                        continue;
                    }
                    savedBinnaryBedVar[1]++;
                    bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                            + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
                    bwPed.write("\n");
                }
                bwPed.close();

                File kedFile = new File(options.outputFileName + ".bed");
                if (kedFile.exists()) {
                    kedFile.delete();
                }

                rafBed = new RandomAccessFile(kedFile, "rw");
                fileChannelBed = rafBed.getChannel();

                int bufSize = 1024;

                ByteBuffer byteBuffer = ByteBuffer.allocate(bufSize);

                //|-magic number-
                //01101100 00011011
                byte byteInfo = (byte) 0x6C;
                byteBuffer.put(byteInfo);
                byteInfo = (byte) 0x1B;
                byteBuffer.put(byteInfo);
                //|-mode-| 00000001 (SNP-major)
                //00000001 
                byteInfo = 1;

                byteBuffer.put(byteInfo);
                byteBuffer.flip();
                fileChannelBed.write(byteBuffer);
                byteBuffer.clear();
            }

            FileChannel fileChannelKed = null;
            RandomAccessFile rafKed = null;
            BufferedWriter bwMapKed = null;
            int[] savedBinnaryKedVar = new int[2];
            savedBinnaryKedVar[0] = 0;
            if (options.isBinaryGtyOut) {

                File kedFile = new File(options.outputFileName + ".ked");
                if (kedFile.exists()) {
                    kedFile.delete();
                }
                rafKed = new RandomAccessFile(kedFile, "rw");
                fileChannelKed = rafKed.getChannel();
                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                //|-magic number-
                //10011110 10000010 
                byte byteInfo = (byte) 0x9E;
                byteBuffer.put(byteInfo);
                byteInfo = (byte) 0x82;
                byteBuffer.put(byteInfo);
                //|-mode-| Mode of 00000000 indicates unphased genotypes while that of 00000001 indicates the phased genotypes
                //00000000 
                if (uniqueGenome.isIsPhasedGty()) {
                    byteInfo = 1;
                } else {
                    byteInfo = 0;
                }

                byteBuffer.put(byteInfo);
                byteBuffer.flip();
                fileChannelKed.write(byteBuffer);
                byteBuffer.clear();
//pedigree 
                BufferedWriter bwPed = new BufferedWriter(new FileWriter(options.outputFileName + ".fam"));
                for (Individual indiv : subjectList) {
                    if (indiv == null) {
                        continue;
                    }
                    savedBinnaryKedVar[1]++;
                    bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                            + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
                    bwPed.write("\n");
                }
                bwPed.close();
                bwMapKed = new BufferedWriter(new FileWriter(options.outputFileName + ".kim"));

            }

            File vcfFilteredInFile = null;
            BufferedWriter vcfFilteredInFileWriter = null;
            if (options.isVCFOut) {
                vcfFilteredInFile = new File(options.outputFileName + ".flt.vcf");
                vcfFilteredInFileWriter = new BufferedWriter(new FileWriter(vcfFilteredInFile));
                vcfFilteredInFileWriter.write(vsParser.getVcfHead().toString());
                vcfFilteredInFileWriter.write("#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT");
                for (Individual indiv : subjectList) {
                    vcfFilteredInFileWriter.write("\t");
                    vcfFilteredInFileWriter.write(indiv.getLabelInChip());
                }
                vcfFilteredInFileWriter.write("\n");
            }
            // BufferedWriter tmpWriter = new BufferedWriter(new FileWriter(options.outputFileName + ".maf"));
            // tmpWriter.write("chr	pos	ref_allele	newbase	classification\n");
            if (options.excelOut) {
                // finalFilteredInFile = new File(options.outputFileName +
                // ".flt.xls");
                finalFilteredInFile = new File(options.outputFileName + ".flt.xlsx.tmp");
            } else {
                finalFilteredInFile = new File(options.outputFileName + ".flt.txt");
            }

            BufferedWriter finalExportWriter = new BufferedWriter(new FileWriter(finalFilteredInFile));

            // as it is fast, i would prefer to read the lenght always. 
            Map<String, Double> geneLengths = null;
            if (options.geneDBLabels != null) {
                GeneRegionParser grp = new GeneRegionParser();
                // geneLengths =
                // grp.readRefGeneLength(GlobalManager.RESOURCE_PATH + "/" +
                // options.PUBDB_FILE_MAP.get(options.geneDBLabels[0]),
                // options.splicingDis);
                String[] pathes = new String[options.geneDBLabels.length];
                int ii = 0;
                for (String lbs : options.geneDBLabels) {
                    pathes[ii] = GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get(lbs);
                    ii++;
                }
                geneLengths = grp.readMergeRefGeneCodingLength(pathes, options.splicingDis, true);
            }

//-------------------------------------------------------------------Start to filter or annotate 
            Chromosome[] chromosomes = uniqueGenome.getChromosomes();

            int leftVar = -1;
            boolean needHead = true;

            //uniqueGenome.loadAllGtySettingsFromDisk();
            boolean hasLoadGty = false;
            boolean hasLoadRead = false;
            List<String> tmpFileOrderList = new ArrayList<String>();
            VCFBitGtySetting[] vCFBitGtySetting = uniqueGenome.getvCFBitGtySetting();
            for (int chromID = 0; chromID < chromosomes.length; chromID++) {
                for (Individual indiv : subjectList) {
                    indiv.markerGtySetArray[chromID].releaseAllSpace();
                }

                tmpFileOrderList.clear();
                uniqueGenome.loadVariantFromDisk(chromID, tmpFileOrderList);
                List<Variant> chromosomeVar = chromosomes[chromID].variantList;
                if (chromosomeVar == null || chromosomeVar.isEmpty()) {
                    continue;
                }
                hasLoadGty = false;
                //More variant QC
                varFilter.sumFilterCaseControlVar(chromosomes[chromID], options.minHetA, options.minHomA, options.minHetU, options.minHomU, options.minOBSA, options.minOBSU, minMissingQCFilter);
                if (chromosomeVar.isEmpty()) {
                    //   LOG.info("0 sequence variant(s) are left finally!");
                }
                if (needGty && !hasLoadGty) {
                    uniqueGenome.loadGenotypesFromDisk(chromID, subjectList, tmpFileOrderList);
                    hasLoadGty = true;
                }
                if (inheritanceModelFilter != null) {
                    varFilter.inheritanceModelFilterVar(chromosomes[chromID], uniqueGenome.isIsPhasedGty(), subjectList, genotypeFilters, hardFilterModel, vCFBitGtySetting[chromID], inheritanceModelFilter);
                }
                if (denovoModelFilter != null) {
                    uniqueGenome.loadReadsFromDisk(chromID, subjectList, tmpFileOrderList);
                    varFilter.devnoMutationFilterVar(chromosomes[chromID], uniqueGenome.isIsPhasedGty(), subjectList, setSampleIDList, options.noHomo, vCFBitGtySetting[chromID], denovoModelFilter);
                    uniqueGenome.cleanReadInfor(chromID, subjectList);
                }

                if (needGty && options.sampleGtyHardFilterCode != null && (options.sampleGtyHardFilterCode.contains("8"))) {
                    uniqueGenome.loadReadsFromDisk(chromID, subjectList, tmpFileOrderList);
                    varFilter.somaticMutationFilterVar(chromosomes[chromID], uniqueGenome.isIsPhasedGty(), subjectList, setSampleIDList, setSampleLabelList, vCFBitGtySetting[chromID], somaticModelFilter, options.somatReadsP);
                    uniqueGenome.cleanReadInfor(chromID, subjectList);
                }

                if (varaintDBHardFilterFiles != null) {
                    for (int i = 0; i < varaintDBHardFilterFiles.length; i++) {
                        leftVar = varAnnoter.hardFilterByANNOVARefFormat(chromosomes[chromID], chromID, varaintDBHardFilterFiles[i], options.needProgressionIndicator);
                        if (leftVar == 0) {
                            break;
                        }
                        chromosomes[chromID].buildVariantIndexMap();
                    }
                }

                if (varaintDBFilterFiles != null) {
                    for (int i = 0; i < varaintDBFilterFiles.length; i++) {
                        varAnnoter.markByANNOVARefFormat(chromosomes[chromID], chromID, varaintDBFilterFiles[i], options.needProgressionIndicator);
                    }
                }

                if (referenceGenomes != null) {
                    for (int i = 0; i < referenceGenomes.length; i++) {
                        varAnnoter.geneFeatureAnnot(chromosomes[chromID], chromID, referenceGenomes[i], options.geneFeatureIn, availableFeatureSizeForGeneDB[i]);
                    }
                    //this should not be filttered by gene-feature
                    varAnnoter.summarizeVarPerGene(chromosomes[chromID], somatNumIndex, readInfoIndex);
                    varFilter.geneFeatureFilter(chromosomes[chromID], variantsCounters, options.geneFeatureIn, geneDBFilter);
                }                              

                if (dbNSFPAnnot != null) {
                    for (String dbLabelName : options.scoreDBLableList) {
                        if (dbLabelName.equals("dbnsfp")) {
                            String dbFileName = options.PUBDB_FILE_MAP.get(dbLabelName);
                            varAnnoter.readExonicScoreNSFPNucleotideMerge(chromosomes[chromID], GlobalManager.RESOURCE_PATH + "/" + dbFileName, options.refGenomeVersion,
                                    dbNSFP3ScoreIndexes, dbNSFP3PredicIndex, dbNSFPAnnot, options.needProgressionIndicator);
                        }

                        if (options.causingPredType == 0) {
//riskPredictionRareDiseaseAll(Chromosome chromosome, List<CombOrders> combOrderList, boolean filterNonDisMut, List<String> names, FiltrationSummarySet dbNSFPPred)
                            if (options.predictExplanatoryVar.startsWith("all")) {
                                varAnnoter.riskPredictionRareDiseaseAll(chromosomes[chromID], combOrderList, options.filterNonDiseaseMut, uniqueGenome.getScoreLabels(), options.threadNum, dbNSFPPred);
                            } else if (options.predictExplanatoryVar.startsWith("best")) {
                                varAnnoter.riskPredictionRareDiseaseBest(chromosomes[chromID], combOrderList, options.filterNonDiseaseMut, uniqueGenome.getScoreLabels(), dbNSFPPred);
                            } else {
                                varAnnoter.riskPredictionRareDiseaseFixParam(chromosomes[chromID], fixedComb, options.filterNonDiseaseMut, uniqueGenome.getScoreLabels(), dbNSFPPred);
                            }

                        } else if (options.causingPredType == 2) {
                            //Chromosome chromosome, MyRandomForest myRandomForest, boolean filterNonDisMut, FiltrationSummarySet dbNSFPPred
                            varAnnoter.riskPredictionRandomForest(chromosomes[chromID], myRandomForest, options.threadNum, options.filterNonDiseaseMut, dbNSFPPred);
                        }
                    }
                }
                
                if (dbScSNV != null) {
                    varAnnoter.dbscSNV(chromosomes[chromID], dbScSNV, options.needProgressionIndicator);
                }

                // System.out.println(chromID);

                if (doubleHitGeneModelFilter != null) {
                    varFilter.doubleHitGeneExploreVarTriosSudoControl(chromosomes[chromID], uniqueGenome.isIsPhasedGty(), sortedSubjectList, triosIDList, effectiveIndivIDsTrios, options.meshList, geneNamesMap, genePubMedID,
                            options.noHomo, hitDisCountsGenes, hitDisCounReads, caseDoubleHitGenes, controlDoubleHitGenes, options.countAllPsudoControl, vCFBitGtySetting[chromID], doubleHitGeneModelFilter);
                }
 
                if (options.needAnnotateGene) {
                    String fileNameHg = "HgncGene.txt";
                    File resourceFileHg = new File(GlobalManager.RESOURCE_PATH + "/" + fileNameHg);
                    if (uniqueGenome.getGeneNum() > 0) {
                        varAnnoter.pseudogeneAnnotationGene(chromosomes[chromID], assGene,resourceFileHg.getCanonicalPath());
                    } else if (uniqueGenome.getVarNum() > 0) {                  
                        varAnnoter.pseudogeneAnnotationVar(chromosomes[chromID], assVariant,resourceFileHg.getCanonicalPath());
                    }
                }                   
                
                
                
                
                
                
                
                if (!subjectList.isEmpty()) {
                    if (options.isPlinkBedOut) {
                        uniqueGenome.exportPlinkBinaryGty(subjectList, options.outputFileName);
                    }
                    if (options.isBinaryGtyOut) {
                        uniqueGenome.exportKGGSeqBinaryGty(chromosomes[chromID], subjectList, vCFBitGtySetting[chromID], fileChannelKed, bwMapKed, savedBinnaryKedVar);
                    }
                    if (options.isPlinkPedOut) {
                        uniqueGenome.export2FlatTextPlink(subjectList, options.outputFileName);
                    }
                }
                if (hasLoadGty) {
                    uniqueGenome.cleanBitGenotype(chromID, subjectList);
                }
                // uniqueGenome.export2ATmpFormat(tmpWriter, chromID);
                if (options.isANNOVAROut) {
                    uniqueGenome.export2ANNOVARInput(annovarFilteredInFileWriter, chromID);
                }
                //to release memory, release all lefte variants on this chromosome 
                uniqueGenome.export2FlatText(finalExportWriter, chromID, needHead, options.needRecordAltFreq);
                if (options.needGtyQual) {
                    uniqueGenome.loadGtyQualFromDisk(chromID, subjectList, tmpFileOrderList);
                    uniqueGenome.export2VCFFormat(vcfFilteredInFileWriter, chromID, subjectList, options.missingGty);
                    uniqueGenome.cleanGtyQual(chromID, subjectList);
                }
                chromosomeVar.clear();
                chromosomes[chromID].getPosIndexMap().clear();
                gtyCorrdiates[chromID].clear();
                needHead = false;
            }
            // tmpWriter.close();

            if (vcfFilteredInFileWriter != null) {
                vcfFilteredInFileWriter.close();
            }
            if (finalExportWriter != null) {
                finalExportWriter.close();
            }
            if (annovarFilteredInFileWriter != null) {
                annovarFilteredInFileWriter.close();
            }

            if (referenceGenomes != null) {
                for (int i = 0; i < referenceGenomes.length; i++) {
                    referenceGenomes[i] = null;
                }
            }
            if (minMissingQCFilter != null) {
                String info = minMissingQCFilter.toString();
                if (!info.isEmpty()) {
                    LOG.info(info);
                }
                minMissingQCFilter = null;
            }

            if (inheritanceModelFilter != null) {
                String info = inheritanceModelFilter.toString();
                if (!info.isEmpty()) {
                    LOG.info(info);
                }
                inheritanceModelFilter = null;
            }

            if (denovoModelFilter != null) {
                String info = denovoModelFilter.toString();
                if (!info.isEmpty()) {
                    LOG.info(info);
                }
                denovoModelFilter = null;
            }

            if (somaticModelFilter != null) {
                String info = somaticModelFilter.toString();
                if (info.isEmpty()) {
                    LOG.info(info);
                }

            }
            if (varaintDBHardFilterFiles != null) {
                for (int i = 0; i < varaintDBHardFilterFiles.length; i++) {
                    varaintDBHardFilterFiles[i].getBr().close();
                    String info = varaintDBHardFilterFiles[i].getLeftNum() + " variant(s) are left after hard filtering in database " + varaintDBHardFilterFiles[i].getName() + ", which contains " + varaintDBHardFilterFiles[i].getTotalNum() + " effective variants.";
                    LOG.info(info);
                    varaintDBHardFilterFiles[i] = null;
                }
            }
            

            if (varaintDBFilterFiles != null) {
                for (int i = 0; i < varaintDBFilterFiles.length; i++) {
                    varaintDBFilterFiles[i].getBr().close();
                    String info = varaintDBFilterFiles[i].getLeftNum() + " variant(s) exist in " + varaintDBFilterFiles[i].getName() + ", which contains " + varaintDBFilterFiles[i].getTotalNum() + " effective variants.";
                    LOG.info(info);
                    varaintDBFilterFiles[i] = null;
                }
            }

            if (variantsCounters != null) {
                double totolVarNum = 0;
                for (int num : variantsCounters) {
                    totolVarNum += num;
                }
                StringBuilder info = new StringBuilder();
                info.append('\n');
                for (int i = 0; i < VAR_FEATURE_NAMES.length; i++) {
                    info.append(i).append(".").append(VAR_FEATURE_NAMES[i]).append(": ").append(variantsCounters[i]).append(" (")
                            .append(Util.doubleToString(variantsCounters[i] * 100 / totolVarNum, 3)).append("%)\n");
                }
                LOG.info(info);
                LOG.info(geneDBFilter.toString());
            }

            if (dbNSFPAnnot != null) {
                String info = dbNSFPAnnot.toString();
                if (!info.isEmpty()) {
                    LOG.info(info);
                }
            }
            if (dbNSFPPred != null) {
                LOG.info(dbNSFPPred.toString(0, 3, " "));
                String info = dbNSFPPred.toString(3, 4, "");
                if (!info.isEmpty()) {
                    LOG.info(info);
                }
            }

            if (dbScSNV != null) {
                dbScSNV.getBr().close();
                String info = dbScSNV.getLeftNum() + " variant(s) exist in " + dbScSNV.getName() + ", which contains " + dbScSNV.getTotalNum() + " effective variants.";
                LOG.info(info);
                dbScSNV = null;
            }
            if (doubleHitGeneModelFilter != null) {
                int hitGenenNum = hitDisCountsGenes.size();
                for (int i = 2; i < hitGenenNum; i++) {
                    String[] row = hitDisCountsGenes.get(i);
                    Double lens = geneLengths.get(row[0]);
                    if (lens == null) {
                        row[2] = "0";
                        hitDisCountsGenes.get(i)[2] = row[2];
                        hitDisCounReads.get(i)[2] = row[2];
                    } else {
                        row[2] = String.valueOf(lens);
                        hitDisCountsGenes.get(i)[2] = row[2];
                        hitDisCounReads.get(i)[2] = row[2];
                    }

                }

                StringBuilder info = new StringBuilder();
                String info1 = doubleHitGeneModelFilter.toString();
                if (info1.isEmpty()) {
                    info.append(info1).append('\n');
                }

                String outFileName = options.outputFileName + ".doublehit.gene.trios.flt";

                List<List<String[]>> arrys = new ArrayList<List<String[]>>();

                arrys.add(hitDisCountsGenes);
                arrys.add(hitDisCounReads);

                if (options.excelOut) {
                    List<String> sheetLabels = new ArrayList<String>();
                    sheetLabels.add("counts");
                    sheetLabels.add("genotypes");

                    File savedFile = new File(outFileName + ".xlsx");
                    LocalExcelFile.writeMultArray2XLSXFile(savedFile.getCanonicalPath(), arrys, sheetLabels, true, 0);
                    info.append("All POSSIBLE double-hit genes are saved in ").append(savedFile.getCanonicalPath()).append(".");
                } else {
                    File savedFile1 = new File(outFileName + ".count.txt");
                    LocalFile.writeData(savedFile1.getCanonicalPath(), arrys.get(0), "\t", false);
                    File savedFile2 = new File(outFileName + ".gty.txt");
                    LocalFile.writeData(savedFile2.getCanonicalPath(), arrys.get(1), "\t", false);
                    info.append("All POSSIBLE double-hit genes are saved in ").append(savedFile1.getCanonicalPath()).append(" and ").append(savedFile2.getCanonicalPath()).append(".");
                }

                info.append("\nThe double-hit genes:\n");
                if (!caseDoubleHitGenes.isEmpty()) {
                    info.append("in cases: ").append(caseDoubleHitGenes.size()).append("\n").append(caseDoubleHitGenes.toString()).append("\n");
                }
                LOG.info(info);
            }

            if (options.isBinaryGtyOut) {
                if (bwMapKed != null) {
                    bwMapKed.close();
                }
                if (fileChannelKed != null) {
                    fileChannelKed.close();
                    rafKed.close();
                }
                String info = "Genotype of " + savedBinnaryKedVar[0] + " sequence variant(s) and " + subjectList.size() + " individuals are saved \nin "
                        + options.outputFileName + ".fam " + options.outputFileName + ".kim " + options.outputFileName + ".ked " + " with KGGSseq binary genotype format.";
                LOG.info(info);
            }

            if (options.isANNOVAROut) {
                LOG.info("Final variants are saved in " + annovarFilteredInFile.getCanonicalPath() + " with ANNOVAR format.");
            }

            if (options.excelOut) {
                File finalFilteredInFile1 = new File(options.outputFileName + ".flt.xlsx");
                //As the function of appending data into an existing file is very slow; So I just have convert a text file into an excel file 
                LocalExcelFile.convertTextFile2XLSXFile(finalFilteredInFile.getCanonicalPath(), finalFilteredInFile1.getCanonicalPath(), true, 4);
                //Remove the text file to save storage space
                finalFilteredInFile.delete();
                LOG.info("Finally, " + uniqueGenome.getVarNum() + " variants are saved in " + finalFilteredInFile1.getCanonicalPath() + " with Excel format.\n\n");
            } else {
                LOG.info("Finally," + uniqueGenome.getVarNum() + " variants are saved in " + finalFilteredInFile.getCanonicalPath() + " with flat text format.\n\n");
            }

            //-----------------------Annotate genes and gene sets on whole genome-------------------------------
            String[] cells = null;
            GeneAnnotator geneAnnotor = new GeneAnnotator();
            Map<String, Map<String, Integer>> cosmicGeneMut = null;
            Map<String, double[]> driverGeneScores = null;
            List<String> scoreNames = new ArrayList<String>();
            if (somaticModelFilter != null) {
                String geneCoVarFilePath = options.PUBDB_FILE_MAP.get("cancer.mutsig");
                geneCoVarFilePath = GlobalManager.RESOURCE_PATH + "/" + geneCoVarFilePath;
                driverGeneScores = geneAnnotor.readMutationGeneScore(geneCoVarFilePath, scoreNames);

                if (options.cosmicAnnotate) {
                    fileName = options.PUBDB_FILE_MAP.get("cosmicdb");
                    cosmicGeneMut = geneAnnotor.readCosmicGeneAnnotation(GlobalManager.RESOURCE_PATH + "/" + fileName);
                }
            }

            if (options.causingPredType == 2) {
                geneAnnotor.summarizeSomaticDriverGene(uniqueGenome, geneLengths, cosmicGeneMut, driverGeneScores, scoreNames, options.pathwayHyperGenePCut, options.outputFileName + ".gene.xlsx");
            }

        } finally {
            if (uniqueGenome != null) {
                //  uniqueGenome.removeTempFileFromDisk();
            }
        }
    }
}
