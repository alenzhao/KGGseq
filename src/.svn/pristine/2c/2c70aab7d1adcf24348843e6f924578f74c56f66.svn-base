/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.cobi.kggseq.entity;

import cern.colt.map.OpenIntIntHashMap;
import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.cobi.kggseq.Constants;
import org.cobi.kggseq.GlobalManager;
import org.cobi.util.file.LocalFileFunc;

import org.cobi.util.text.LocalExcelFile;
import org.cobi.util.text.LocalFile;
import org.objenesis.strategy.StdInstantiatorStrategy;

/**
 *
 * @author MX Li
 */
public class Genome implements Constants {

    Kryo kryo = new Kryo();

    Map<String, Integer> chromNameIndexMap = new HashMap<String, Integer>();
    /**
     * @pdOid 919fbd33-2725-4ec8-934c-52dbb4580123
     */
    private String name;
    /**
     * @pdOid 65e6e40e-de4a-4b64-9c2d-c71a70bc879e
     */
    private String storagePath;
    /**
     * @pdRoleInfo migr=no name=Chromosome assc=association14 mult=0..*
     * type=Aggregation
     */
    private Chromosome[] chromosomes;
    private Map<String, int[]> mRNAIndexMap = new HashMap<String, int[]>();
    private VCFBitGtySetting[] vCFBitGtySetting;
    //private OpenIntIntHashMap[] variantPositionIndexMap = new OpenIntIntHashMap[STAND_CHROM_NAMES.length];
    //a temple Variant to save time when look up a variant by binary search
    Variant tmpVar = new Variant(-1, ".", new String[]{"."});
    Gene tmpGene = new Gene("No", -1, -1);
    List<String> variantScoreLabels = new ArrayList<String>();
    List<String> variantFeatureLabels = new ArrayList<String>();
    List<String> geneFeatureLabels = new ArrayList<String>();
    List<String> geneScoreLabels = new ArrayList<String>();
    int geneNum = 0;
    int varNum = 0;
    boolean isPhasedGty = false;
    final String UNKNOWN_CHROM_NAME0 = "Un";
    final String UNKNOWN_CHROM_NAME1 = "GL";
    boolean refSeqAnnot = false;
    boolean gencodeAnnot = false;
    boolean knownAnnot = false;
    boolean ensemblAnnot = false;
    boolean needAccoundAffect = false;
    boolean needAccoundUnaffect = false;
    boolean needAccoundAll = false;

    public boolean isNeedAccoundAffect() {
        return needAccoundAffect;
    }

    public void setNeedAccoundAffect(boolean needAccoundAffect) {
        this.needAccoundAffect = needAccoundAffect;
    }

    public boolean isNeedAccoundAll() {
        return needAccoundAll;
    }

    public void setNeedAccoundAll(boolean needAccoundAll) {
        this.needAccoundAll = needAccoundAll;
    }

    public boolean isNeedAccoundUnaffect() {
        return needAccoundUnaffect;
    }

    public void setNeedAccoundUnaffect(boolean needAccoundUnaffect) {
        this.needAccoundUnaffect = needAccoundUnaffect;
    }

    public Map<String, Integer> getChromNameIndexMap() {
        return chromNameIndexMap;
    }

    public boolean isKnownAnnot() {
        return knownAnnot;
    }

    public void setKnownAnnot(boolean knownAnnot) {
        this.knownAnnot = knownAnnot;
    }

    public boolean isGencodeAnnot() {
        return gencodeAnnot;
    }

    public boolean isEnsemblAnnot() {
        return ensemblAnnot;
    }

    public void setEnsemblAnnot(boolean ensemblAnnot) {
        this.ensemblAnnot = ensemblAnnot;
    }

    public void setGencodeAnnot(boolean gencodeAnnot) {
        this.gencodeAnnot = gencodeAnnot;
    }

    public boolean isRefSeqAnnot() {
        return refSeqAnnot;
    }

    public void setRefSeqAnnot(boolean refSeqAnnot) {
        this.refSeqAnnot = refSeqAnnot;
    }

    public boolean isIsPhasedGty() {
        return isPhasedGty;
    }

    public void setIsPhasedGty(boolean isPhasedGty) {
        this.isPhasedGty = isPhasedGty;
    }

    public void addVariantScoreLabel(String score) {
        variantScoreLabels.add(score);
    }

    public int getGeneNum() {
        return geneNum;
    }

    public void setmRNANum(int geneNum) {
        this.geneNum = geneNum;
    }

    public List<String> getVariantFeatureLabels() {
        return variantFeatureLabels;
    }

    public void addVariantFeatureLabel(String labels) {
//        if(variantFeatureLabels.contains(labels))   return;
        variantFeatureLabels.add(labels);
    }

    public int getVariantFeatureNum() {
        return variantFeatureLabels.size();
    }

    public void addVariantFeatureLabels(List<String> labels) {
        variantFeatureLabels.addAll(labels);
    }

    public void addmRNAFeatureLabel(String labels) {
//        if(geneFeatureLabels.contains(labels))  return;
        geneFeatureLabels.add(labels);
    }
    
    public int getmRNAFeatureNum(){
        return geneFeatureLabels.size();
    }

    public void addmRNAScoreLabel(String labels) {
        geneScoreLabels.add(labels);
    }

    public void addGeneFeatureLabels(List<String> labels) {
        geneFeatureLabels.addAll(labels);
    }

    public void addGeneFeatureLabel(String label) {
        geneFeatureLabels.add(label);
    }

    public List<String> getGeneFeatureLabels() {
        return geneFeatureLabels;
    }

    public Chromosome[] getChromosomes() {
        return chromosomes;
    }

    public String getName() {
        return name;
    }

    public String getStoragePath() {
        return storagePath;
    }

    public int getVarNum() {
        return varNum;
    }

    public void setVarNum(int varNum) {
        this.varNum = varNum;
    }

    public Genome(String name, String storagePath) {
        this.name = name;
        this.storagePath = storagePath + "TMP";

        chromosomes = new Chromosome[STAND_CHROM_NAMES.length];
        vCFBitGtySetting = new VCFBitGtySetting[STAND_CHROM_NAMES.length];
        for (int i = 0; i < STAND_CHROM_NAMES.length; i++) {
            chromosomes[i] = new Chromosome(STAND_CHROM_NAMES[i], i);
            chromNameIndexMap.put(STAND_CHROM_NAMES[i], i);
            vCFBitGtySetting[i] = new VCFBitGtySetting();
        }
        kryo.setReferences(false);
        kryo.setRegistrationRequired(false);
        kryo.setInstantiatorStrategy(new StdInstantiatorStrategy());
        kryo.register(char[].class);
        kryo.register(long[].class);
        kryo.register(float[].class);
        kryo.register(String[].class);
        kryo.register(Variant.class);
        kryo.register(StringBuilder.class);

        kryo.register(VCFBitGtySet.class);
        kryo.register(OpenIntIntHashMap.class);
        kryo.register(VCFBitGtySetting.class);

    }

    public VCFBitGtySetting[] getvCFBitGtySetting() {
        return vCFBitGtySetting;
    }

    public void loadVariantFromDisk(int chromID, List<String> tmpFileOrderList) {
        String chrNameP = "Chromosome." + STAND_CHROM_NAMES[chromID];
        List<Variant> varList = chromosomes[chromID].variantList;
        varList.clear();
        Variant var = null;

        try {
            File[] files = new File(storagePath).listFiles();
            int genotyeSize = 0;
            for (File file : files) {
                if (!file.getName().contains(chrNameP + ".var.obj.")) {
                    continue;
                }
                genotyeSize = varList.size();
                Input input = new Input(new FileInputStream(file), 1024 * 1024);

                while (!input.eof()) {
                    var = (Variant) kryo.readObject(input, Variant.class);
                    var.genotypeIndex = var.genotypeIndex + genotyeSize;
                    varList.add(var);
                }
                // System.out.println(varList.size());
                input.close();
                tmpFileOrderList.add(file.getName());
                String filePath = file.getCanonicalPath();

                filePath = filePath.replaceAll(chrNameP + ".var.obj.", chrNameP + ".gtysetting.obj.");
                File file1 = new File(filePath);
                if (!file1.exists()) {
                    continue;
                }
                input = new Input(new FileInputStream(filePath), 1024 * 1024);
                VCFBitGtySetting netSetting = (VCFBitGtySetting) kryo.readObject(input, VCFBitGtySetting.class);

                vCFBitGtySetting[chromID].mergeVCFBitGtySetting(netSetting);
                // System.out.println(varList.size());
                input.close();
            }
            Collections.sort(varList, new VariantPositionComparator());

        } catch (Exception ex) {
            ex.printStackTrace();
        }

    }

    public void loadAllGtySettingsFromDisk() {
        for (int chromID = 0; chromID < STAND_CHROM_NAMES.length; chromID++) {
            String chrNameP = "Chromosome." + STAND_CHROM_NAMES[chromID];
            try {
                vCFBitGtySetting[chromID] = new VCFBitGtySetting();

                chrNameP = "." + chrNameP + ".gtysetting.obj.";
                File[] files = new File(storagePath).listFiles();
                for (File file : files) {
                    if (!file.getName().contains(chrNameP)) {
                        continue;
                    }
                    Input input = new Input(new FileInputStream(file), 1024 * 1024);
                    VCFBitGtySetting netSetting = (VCFBitGtySetting) kryo.readObject(input, VCFBitGtySetting.class);

                    vCFBitGtySetting[chromID].mergeVCFBitGtySetting(netSetting);
                    // System.out.println(varList.size());
                    input.close();
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }

    public void loadGenotypesFromDisk(int chromID, List<Individual> subjectList, List<String> tmpFileOrderList) {
        String chrNameP = "Chromosome." + STAND_CHROM_NAMES[chromID];

        VCFBitGtySet gtyset = null;
        try {
            for (String fileName : tmpFileOrderList) {
                String filePath = fileName.replaceAll(chrNameP + ".var.obj.", chrNameP + ".gty.obj.");
                File file = new File(storagePath + File.separator + filePath);
                Input input = new Input(new FileInputStream(file), 1024 * 1024);
                for (Individual indiv : subjectList) {
                    gtyset = (VCFBitGtySet) kryo.readObject(input, VCFBitGtySet.class);
                    indiv.markerGtySetArray[chromID].mergeBitGty(gtyset);
                }
                // System.out.println(varList.size());
                input.close();
            }

        } catch (Exception ex) {
            ex.printStackTrace();
        }

    }

    public void loadReadsFromDisk(int chromID, List<Individual> subjectList, List<String> tmpFileOrderList) {
        String chrNameP = "Chromosome." + STAND_CHROM_NAMES[chromID];
        char[] gtyset = null;
        try {
            for (String fileName : tmpFileOrderList) {
                String filePath = fileName.replaceAll(chrNameP + ".var.obj.", chrNameP + ".read.obj.");
                File file = new File(storagePath + File.separator + filePath);
                Input input = new Input(new FileInputStream(file), 1024 * 1024);
                Integer effectiveIndex = (Integer) kryo.readObject(input, Integer.class);
                for (Individual indiv : subjectList) {
                    gtyset = (char[]) kryo.readObject(input, char[].class);
                    indiv.markerGtySetArray[chromID].mergeReadInfor(gtyset, effectiveIndex);
                }
                // System.out.println(varList.size());
                input.close();
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public void cleanReadInfor(int chromID, List<Individual> subjectList) {
        for (Individual indiv : subjectList) {
            indiv.markerGtySetArray[chromID].readInfor = null;
            indiv.markerGtySetArray[chromID].availableReadInfor = 0;
        }
    }

    public void cleanGtyQual(int chromID, List<Individual> subjectList) {
        for (Individual indiv : subjectList) {
            indiv.markerGtySetArray[chromID].detailedGtyQual = null;
            indiv.markerGtySetArray[chromID].availableGtyQual = 0;
        }
    }

    public void cleanBitGenotype(int chromID, List<Individual> subjectList) {
        for (Individual indiv : subjectList) {
            indiv.markerGtySetArray[chromID].biallelicGtySetArray = null;
            indiv.markerGtySetArray[chromID].extraGtySetArray = null;
            indiv.markerGtySetArray[chromID].availableBitIndexBiallelic = 0;
            indiv.markerGtySetArray[chromID].availableBitIndexExtrallelic = 0;
        }
    }

    public void loadGtyQualFromDisk(int chromID, List<Individual> subjectList, List<String> tmpFileOrderList) {
        String chrNameP = "Chromosome." + STAND_CHROM_NAMES[chromID];
        for (Individual indiv : subjectList) {
            indiv.clearnBitGty(chromID);
        }

        String[] gtyset = null;
        try {
            for (String fileName : tmpFileOrderList) {
                String filePath = fileName.replaceAll(chrNameP + ".var.obj.", chrNameP + ".gtyqual.obj.");

                File file = new File(storagePath + File.separator + filePath);
                if (!file.exists()) {
                    continue;
                }
                Input input = new Input(new FileInputStream(file), 1024 * 1024);
                Integer effectiveIndex = (Integer) kryo.readObject(input, Integer.class);

                for (Individual indiv : subjectList) {
                    gtyset = (String[]) kryo.readObject(input, String[].class);
                    indiv.markerGtySetArray[chromID].mergeGtyQualInfor(gtyset, effectiveIndex);
                }

                // System.out.println(varList.size());
                input.close();
            }

        } catch (Exception ex) {
            ex.printStackTrace();
        }

    }

    public void writeChromsomeToDiskClean() {
        int chromID = -1;
        String chromeName;
        int threadID = 0;
        try {
            for (Chromosome chrome : chromosomes) {
                List<Variant> varList = chrome.variantList;
                chromID++;
                chromeName = STAND_CHROM_NAMES[chromID];
                if (varList.isEmpty()) {
                    continue;
                }
                int fileIndex = -1;
                String chrNameP = "Chromosome." + chromeName;
                chrNameP = threadID + "." + chrNameP;
                File fileName = null;
                File folder = new File(storagePath);
                if (folder.exists()) {
                    do {
                        fileIndex++;
                        fileName = new File(storagePath + File.separator + chrNameP + ".var.obj." + fileIndex);
                    } while (fileName.exists());
                } else {
                    fileIndex++;
                    folder.mkdirs();
                }

                //comments: both Kryo and FSTObjectOutput are excellent tools for Serializationl. However, the former produced slightly smaller file and was slightly faster. So I used Kryo
                fileName = new File(storagePath + File.separator + chrNameP + ".var.obj." + fileIndex);
                //slower
                //  kryo.setInstantiatorStrategy(new SerializingInstantiatorStrategy());            
                Output output = new Output(new FileOutputStream(fileName), 1024 * 1024);
                //  output.setBuffer(buffer);

                for (Variant var : varList) {
                    kryo.writeObject(output, var);
                }
                output.flush();
                output.close();
                varList.clear();
            }
            System.gc();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public void writeChromosomeToDiskClean(List<Individual> subjectList, boolean needGty, boolean needReadInfo, boolean needGtyQaul) throws Exception {
        for (Chromosome chrome : chromosomes) {
            String chromeName = chrome.getName();
            List<Variant> varList = chrome.variantList;
            if (varList.isEmpty()) {
                continue;
            }
            int chromID = chrome.id;
            int fileIndex = 0;
            String chrNameP = "Chromosome." + chromeName;
            File folder = new File(storagePath);
            if (folder.exists()) {
                boolean findOnce = false;
                for (final File fileEntry : folder.listFiles()) {
                    if (!fileEntry.isDirectory()) {
                        String name = fileEntry.getName();
                        if (!name.contains(chrNameP)) {
                            continue;
                        }
                        int index = name.lastIndexOf(".var.obj");
                        if (index < 0) {
                            continue;
                        }
                        index = Integer.parseInt(name.substring(index + 9));
                        if (fileIndex < index) {
                            fileIndex = index;
                        }
                        findOnce = true;
                        // System.out.println(fileEntry.getName());
                    }
                }
                if (findOnce) {
                    fileIndex++;
                }
            } else {
                folder.mkdirs();
            }

            //comments: both Kryo and FSTObjectOutput are excellent tools for Serializationl. However, the former produced slightly smaller file and was slightly faster. So I used Kryo
            File fileName = new File(storagePath + File.separator + chrNameP + ".var.obj." + fileIndex);
            //slower
            //  kryo.setInstantiatorStrategy(new SerializingInstantiatorStrategy());            
            Output output = new Output(new FileOutputStream(fileName), 1024 * 1024);
            //  output.setBuffer(buffer);

            for (Variant var : varList) {
                kryo.writeObject(output, var);
            }
            output.flush();
            output.close();
            varList.clear();
            if (subjectList != null) {
                if (needReadInfo) {
                    fileName = new File(storagePath + File.separator + chrNameP + ".read.obj." + fileIndex);
                    output = new Output(new FileOutputStream(fileName), 1024 * 1024);
                    kryo.writeObject(output, subjectList.get(0).markerGtySetArray[chromID].availableReadInfor);
                    for (Individual indivA : subjectList) {
                        kryo.writeObject(output, (indivA.markerGtySetArray[chromID].readInfor));
                        indivA.markerGtySetArray[chromID].readInfor = new char[0];
                    }
                    output.flush();
                    output.close();
                }

                if (needGtyQaul) {
                    fileName = new File(storagePath + File.separator + chrNameP + ".gtyqual.obj." + fileIndex);
                    output = new Output(new FileOutputStream(fileName), 1024 * 1024);
                    kryo.writeObject(output, subjectList.get(0).markerGtySetArray[chromID].availableGtyQual);
                    for (Individual indivA : subjectList) {
                        kryo.writeObject(output, indivA.markerGtySetArray[chromID].detailedGtyQual);
                        indivA.markerGtySetArray[chromID].detailedGtyQual = new String[0];
                    }
                    output.flush();
                    output.close();
                }
                if (needGty) {
                    fileName = new File(storagePath + File.separator + chrNameP + ".gty.obj." + fileIndex);
                    output = new Output(new FileOutputStream(fileName), 1024 * 1024);
                    for (Individual indivA : subjectList) {
                        kryo.writeObject(output, indivA.markerGtySetArray[chromID]);
                        indivA.markerGtySetArray[chromID].availableBitIndexBiallelic = 0;
                        indivA.markerGtySetArray[chromID].availableBitIndexExtrallelic = 0;
                        indivA.markerGtySetArray[chromID].biallelicGtySetArray = new long[0];
                        indivA.markerGtySetArray[chromID].extraGtySetArray = new long[0];
                        indivA.markerGtySetArray[chromID].availableReadInfor = 0;
                        indivA.markerGtySetArray[chromID].availableGtyQual = 0;
                    }
                    output.flush();
                    output.close();

                    fileName = new File(storagePath + File.separator + chrNameP + ".gtysetting.obj." + fileIndex);
                    output = new Output(new FileOutputStream(fileName), 1024 * 1024);
                    kryo.writeObject(output, vCFBitGtySetting[chromID]);

                    output.flush();
                    output.close();
                    vCFBitGtySetting[chromID].cleanAllIndexes();
                }

            }

        }
        System.gc();
    }

    public void removeTempFileFromDisk() throws Exception {
        LocalFileFunc.delAll(new File(storagePath));
    }

    public List<String> getScoreLabels() {
        return variantScoreLabels;
    }

    public void addGeneFullChromName(String chromName, mRNA var) {
        chromName = chromName.substring(3);
        if (chromName.startsWith(UNKNOWN_CHROM_NAME0) | chromName.startsWith(UNKNOWN_CHROM_NAME1)) {
            return;
        }
        Integer chromID = chromNameIndexMap.get(chromName);
        if (chromID == null) {
            System.err.println("Unrecognized chromosome name: " + chromName);
            return;
        }

        mRNAIndexMap.put(var.refID, new int[]{chromID, chromosomes[chromID].mRNAList.size()});
        chromosomes[chromID].addmRNA(var);

    }

    public void addANullFeature2Variants(String missingVa) {
        int featureNum = variantFeatureLabels.size();
        for (int c = 0; c < chromosomes.length; c++) {
            if (chromosomes[c] != null) {
                for (Variant var : chromosomes[c].variantList) {
                    var.addFeatureValue(featureNum, missingVa);
                }
            }
        }
    }

    public void addVariantList(String chromName, List<Variant> vars) {
        if (chromName.startsWith(UNKNOWN_CHROM_NAME0) | chromName.startsWith(UNKNOWN_CHROM_NAME1)) {
            return;
        }
        Integer chromID = chromNameIndexMap.get(chromName);
        if (chromID == null) {
            System.err.println("Unrecognized chromosome name: " + chromName);
            return;
        }

        chromosomes[chromID].variantList.addAll(vars);
        chromosomes[chromID].setHasNotOrderVariantList(true);
    }

    public void addVariantList(int chromID, List<Variant> vars) {
        chromosomes[chromID].variantList.addAll(vars);
        chromosomes[chromID].setHasNotOrderVariantList(true);
    }

    public Variant getVariant(String chromName, int index) {
        if (chromName.startsWith(UNKNOWN_CHROM_NAME0) | chromName.startsWith(UNKNOWN_CHROM_NAME1)) {
            return null;
        }
        Integer chromID = chromNameIndexMap.get(chromName);
        if (chromID == null) {
            //System.err.println("Unrecognized chromosome name: " + chromName);
            return null;
        }
        return chromosomes[chromID].variantList.get(index);
    }

    public Variant[] lookupVariants(String chromName, int sartPostion, int endPostion) throws Exception {
        if (chromName.startsWith(UNKNOWN_CHROM_NAME0) | chromName.startsWith(UNKNOWN_CHROM_NAME1)) {
            return null;
        }
        Integer chromID = chromNameIndexMap.get(chromName);
        if (chromID == null) {
            //System.err.println("Unrecognized chromosome name: " + chromName);
            return null;
        }
        if (chromosomes[chromID].variantList.isEmpty()) {
            return null;
        }
        if (sartPostion > endPostion) {
            int postion = sartPostion;
            sartPostion = endPostion;
            endPostion = postion;
        }
        int startIndex = -1;
        int endIndex = -1;
        tmpVar.refStartPosition = sartPostion;
        int index = chromosomes[chromID].lookupVariantByList(tmpVar);
        if (index >= 0) {
            startIndex = index - 1;
            while (startIndex >= 0 && chromosomes[chromID].variantList.get(startIndex).refStartPosition == sartPostion) {
                startIndex--;
            }
            startIndex++;
        } else {
            startIndex = -index - 1;
        }
        if (chromosomes[chromID].variantList.size() <= startIndex) {
            return null;
        }
        tmpVar.refStartPosition = endPostion;
        index = chromosomes[chromID].lookupVariantByList(tmpVar);
        if (index >= 0) {
            endIndex = index + 1;
            while (endIndex < chromosomes[chromID].variantList.size() && chromosomes[chromID].variantList.get(endIndex).refStartPosition == endPostion) {
                endIndex++;
            }
        } else {
            endIndex = -index - 1;
        }

        if (endIndex <= startIndex) {
            return null;
        }
        Variant[] selectVar = new Variant[endIndex - startIndex];
        for (int i = startIndex; i < endIndex; i++) {
            selectVar[i - startIndex] = chromosomes[chromID].variantList.get(i);
        }
        return selectVar;
        /*
         * it is very strange to know that variantPositionIndexMap is twice slower than the binnary search to look up a variants when there are 663 variants
         * but donot know what will happen when there are millions of snps
         if (chromosomes[chromID] == null) {
         return null;
         }
         return chromosomes[chromID].variantList.get(variantPositionIndexMap[chromID].get(postion));
         * 
         */
    }

    public int[] lookupVariantIndexes(String chromName, int postion) throws Exception {
        if (chromName.startsWith(UNKNOWN_CHROM_NAME0) | chromName.startsWith(UNKNOWN_CHROM_NAME1)) {
            return null;
        }
        Integer chromID = chromNameIndexMap.get(chromName);
        if (chromID == null) {
            //System.err.println("Unrecognized chromosome name: " + chromName);
            return null;
        }
        if (chromosomes[chromID].variantList.isEmpty()) {
            return null;
        }
        tmpVar.refStartPosition = postion;
        int index = chromosomes[chromID].lookupVariantByMap(tmpVar);
        if (index < 0) {
            return null;
        }
        int startIndex = index - 1;
        while (startIndex >= 0 && chromosomes[chromID].variantList.get(startIndex).refStartPosition == postion) {
            startIndex--;
        }
        startIndex++;
        int endIndex = index + 1;
        while (endIndex < chromosomes[chromID].variantList.size() && chromosomes[chromID].variantList.get(endIndex).refStartPosition == postion) {
            endIndex++;
        }

        int[] selectVar = new int[endIndex - startIndex];
        for (int i = startIndex; i < endIndex; i++) {
            selectVar[i - startIndex] = i;
        }
        return selectVar;
        /*
         if (variantPositionIndexMap[chromID].containsKey(postion)) {
         return variantPositionIndexMap[chromID].get(postion);
         } else {
         return -1;
         }
         * 
         */
    }

    public List<Variant> getChromVariants(String chromName) throws Exception {
        if (chromName.startsWith(UNKNOWN_CHROM_NAME0) | chromName.startsWith(UNKNOWN_CHROM_NAME1)) {
            return null;
        }
        Integer chromID = chromNameIndexMap.get(chromName);
        if (chromID == null) {
            //System.err.println("Unrecognized chromosome name: " + chromName);
            return null;
        }
        return chromosomes[chromID].variantList;

    }

    public int lookupVariantIndexMin(String chromName, int postion) throws Exception {
        if (chromName.startsWith(UNKNOWN_CHROM_NAME0) | chromName.startsWith(UNKNOWN_CHROM_NAME1)) {
            return -1;
        }
        Integer chromID = chromNameIndexMap.get(chromName);
        if (chromID == null) {
            //System.err.println("Unrecognized chromosome name: " + chromName);
            return -1;
        }

        if (chromosomes[chromID].variantList.isEmpty()) {
            return -1;
        }
        tmpVar.refStartPosition = postion;
        int index = chromosomes[chromID].lookupVariantByList(tmpVar);
        if (index < 0) {
            return index;
        }
        int startIndex = index - 1;
        while (startIndex >= 0 && chromosomes[chromID].variantList.get(startIndex).refStartPosition == postion) {
            startIndex--;
        }
        startIndex++;

        return startIndex;
        /*
         if (variantPositionIndexMap[chromID].containsKey(postion)) {
         return variantPositionIndexMap[chromID].get(postion);
         } else {
         return -1;
         }
         * 
         */
    }

    public int lookupVariantIndexMax(String chromName, int postion) throws Exception {
        if (chromName.startsWith(UNKNOWN_CHROM_NAME0) | chromName.startsWith(UNKNOWN_CHROM_NAME1)) {
            return -1;
        }
        Integer chromID = chromNameIndexMap.get(chromName);
        if (chromID == null) {
            // System.err.println("Unrecognized chromosome name: " + chromName);
            return -1;
        }

        if (chromosomes[chromID].variantList.isEmpty()) {
            return -1;
        }
        tmpVar.refStartPosition = postion;
        int index = chromosomes[chromID].lookupVariantByList(tmpVar);
        if (index < 0) {
            return index;
        }

        int endIndex = index + 1;
        while (endIndex < chromosomes[chromID].variantList.size() && chromosomes[chromID].variantList.get(endIndex).refStartPosition == postion) {
            endIndex++;
        }
        endIndex--;

        return endIndex;
        /*
         if (variantPositionIndexMap[chromID].containsKey(postion)) {
         return variantPositionIndexMap[chromID].get(postion);
         } else {
         return -1;
         }
         * 
         */
    }

    public Variant[] lookupVariants(String chromName, int postion, boolean isIndel, String ref, String[] alt) throws Exception {
        if (chromName.startsWith(UNKNOWN_CHROM_NAME0) | chromName.startsWith(UNKNOWN_CHROM_NAME1)) {
            return null;
        }
        Integer chromID = chromNameIndexMap.get(chromName);
        if (chromID == null) {
            //System.err.println("Unrecognized chromosome name: " + chromName);
            return null;
        }
        if (chromosomes[chromID].variantList.isEmpty()) {
            return null;
        }
        tmpVar.setIsIndel(isIndel);
        tmpVar.setRefAllele(ref);
        tmpVar.setAltAlleles(alt);
        tmpVar.refStartPosition = postion;

        int index = chromosomes[chromID].lookupVariantByMap(tmpVar);
        if (index < 0) {
            return null;
        } else {
            int startIndex = index - 1;
            while (startIndex >= 0 && chromosomes[chromID].variantList.get(startIndex).refStartPosition == postion) {
                startIndex--;
            }
            startIndex++;
            int endIndex = index + 1;
            while (endIndex < chromosomes[chromID].variantList.size() && chromosomes[chromID].variantList.get(endIndex).refStartPosition == postion) {
                endIndex++;
            }

            Variant[] selectVar = new Variant[endIndex - startIndex];
            for (int i = startIndex; i < endIndex; i++) {
                selectVar[i - startIndex] = chromosomes[chromID].variantList.get(i);
            }
            return selectVar;
        }

        /*
         * it is very strange to know that variantPositionIndexMap is twice slower than the binnary search to look up a variants when there are 663 variants
         * but donot know what will happen when there are millions of snps
         if (chromosomes[chromID] == null) {
         return null;
         }
         return chromosomes[chromID].variantList.get(variantPositionIndexMap[chromID].get(postion));
         * 
         */
    }

    //subject to change because given a start-end position there might be multple transcripts
    public mRNA lookupmRNAFullChromName(String chromName, int start, int end) throws Exception {
        chromName = chromName.substring(3);
        if (chromName.startsWith(UNKNOWN_CHROM_NAME0) | chromName.startsWith(UNKNOWN_CHROM_NAME1)) {
            return null;
        }

        Integer chromID = chromNameIndexMap.get(chromName);
        if (chromID == null) {
            // System.err.println("Unrecognized chromosome name: " + chromName);
            return null;
        }
        if (chromosomes[chromID].mRNAList.isEmpty()) {
            return null;
        }
        tmpGene.start = start;
        tmpGene.end = end;

        int index = chromosomes[chromID].lookupmRNA(tmpGene);
        if (index < 0) {
            return null;
        } else {
            return chromosomes[chromID].mRNAList.get(index);
        }
        /*
         * it is very strange to know that variantPositionIndexMap is twice slower than the binnary search to look up a variants when there are 663 variants
         * but donot know what will happen when there are millions of snps
         if (chromosomes[chromID] == null) {
         return null;
         }
         return chromosomes[chromID].variantList.get(variantPositionIndexMap[chromID].get(postion));
         * 
         */
    }

    public mRNA lookupmRNA(String refID) throws Exception {
        if (refID == null) {
            return null;
        }
        int[] posIndex = mRNAIndexMap.get(refID);
        if (posIndex == null) {
            return null;
        }
        return chromosomes[posIndex[0]].mRNAList.get(posIndex[1]);
    }

    public void buildVariantIndexMapOnChromosomes() {
        for (int i = 0; i < chromosomes.length; i++) {
            if (chromosomes[i] != null) {
                chromosomes[i].buildVariantIndexMap();
            }
        }
    }

    public void export2PolyphenInput(String exportPath) throws Exception {
        BufferedWriter bw = new BufferedWriter(new FileWriter(exportPath));
        int alleleNum = 0;
        int i = 0;
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                //format:  chr1:1158631 A/C/G/T
                bw.write("chr" + chromosomes[chromIndex].getName());
                bw.write(":");
                bw.write(String.valueOf(var.refStartPosition));
                bw.write(" ");
                bw.write(String.valueOf(var.getRefAllele()));
                String[] alleles = var.getAltAlleles();
                alleleNum = alleles.length;
                for (i = 0; i < alleleNum; i++) {
                    bw.write("/");
                    bw.write(String.valueOf(alleles[0]));
                }
                bw.write("\n");
            }
        }
        bw.close();
    }

    private List<String[]> makeVariantTableList(boolean outAltAf) {
        List<String> colNumNameList = new ArrayList<String>();
        colNumNameList.add("Chromosome");
        colNumNameList.add("StartPosition");
        colNumNameList.add("ReferenceAlternativeAllele");
        colNumNameList.add("rsID");
        colNumNameList.add("MostImportantFeatureGene");
        colNumNameList.add("MostImportantGeneFeature");
        if (refSeqAnnot) {
            colNumNameList.add("RefGeneFeatures");
        }
        if (gencodeAnnot) {
            colNumNameList.add("GENCODEFeatures");
        }

        if (knownAnnot) {
            colNumNameList.add("UCSCKnownGeneFeatures");
        }
        if (ensemblAnnot) {
            colNumNameList.add("EnsemblFeatures");
        }
        if (needAccoundAffect) {
            colNumNameList.add("AffectedRefHomGtyNum");
            colNumNameList.add("AffectedHetGtyNum");
            colNumNameList.add("AffectedAltHomGtyNum");
        }
        if (needAccoundUnaffect) {
            colNumNameList.add("UnaffectedRefHomGtyNum");
            colNumNameList.add("UnaffectedHetGtyNum");
            colNumNameList.add("UnaffectedAltHomGtyNum");
        }
        if (needAccoundAll) {
            colNumNameList.add("AllRefHomGtyNum");
            colNumNameList.add("AllHetGtyNum");
            colNumNameList.add("AllAltHomGtyNum");
        }

        if (outAltAf) {
            colNumNameList.add("MaxDBAltAF");
        }
        int scoreNum = 0;
        int featureNum = 0;
        if (variantScoreLabels != null) {
            colNumNameList.addAll(variantScoreLabels);
            scoreNum = variantScoreLabels.size();
        }
        if (variantFeatureLabels != null) {
            colNumNameList.addAll(variantFeatureLabels);
            featureNum = variantFeatureLabels.size();
        }

        int index = 0;
        StringBuilder sb = new StringBuilder();
        List<String[]> contens = new ArrayList<String[]>();
        contens.add(colNumNameList.toArray(new String[colNumNameList.size()]));
        List<String> cellValueList = new ArrayList<String>();

        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                cellValueList.clear();

                //format:  chr1 1158631 A/C/G/T rs 
                cellValueList.add(chromosomes[chromIndex].getName());
                cellValueList.add(String.valueOf(var.refStartPosition));

                sb.append(var.getRefAllele());
                for (String alle : var.getAltAlleles()) {
                    sb.append('/');
                    sb.append(alle);
                }
                cellValueList.add(sb.toString());
                sb.delete(0, sb.length());
                cellValueList.add(var.getLabel());
                cellValueList.add(var.geneSymb);
                cellValueList.add(org.cobi.kggseq.Constants.VAR_FEATURE_NAMES[var.smallestFeatureID]);
                if (refSeqAnnot) {
                    cellValueList.add(var.getRefGeneAnnot());
                }
                if (gencodeAnnot) {
                    cellValueList.add(var.getgEncodeAnnot());
                }
                if (knownAnnot) {
                    cellValueList.add(var.getKnownGeneAnnot());
                }
                if (ensemblAnnot) {
                    cellValueList.add(var.getEnsemblGeneAnnot());
                }
                if (needAccoundAffect) {
                    cellValueList.add(String.valueOf(var.getAffectedRefHomGtyNum()));
                    cellValueList.add(String.valueOf(var.getAffectedHetGtyNum()));
                    cellValueList.add(String.valueOf(var.getAffectedAltHomGtyNum()));

                }
                if (needAccoundUnaffect) {
                    cellValueList.add(String.valueOf(var.getUnaffectedRefHomGtyNum()));
                    cellValueList.add(String.valueOf(var.getUnaffectedHetGtyNum()));
                    cellValueList.add(String.valueOf(var.getUnaffectedAltHomGtyNum()));
                }
                if (needAccoundAll) {
                    cellValueList.add(String.valueOf(var.getAffectedRefHomGtyNum()));
                    cellValueList.add(String.valueOf(var.getAffectedHetGtyNum()));
                    cellValueList.add(String.valueOf(var.getAffectedAltHomGtyNum()));
                }

                if (outAltAf) {
                    if (var.altAF == -1) {
                        cellValueList.add("N");
                    } else if (Float.isNaN(var.altAF)) {
                        cellValueList.add(".");
                    } else {
                        cellValueList.add(String.valueOf(var.altAF));
                    }

                }

                if (var.scores != null) {
                    for (double sc : var.scores) {
                        if (Double.isNaN(sc)) {
                            cellValueList.add(".");
                        } else {
                            cellValueList.add(String.valueOf(sc));
                        }
                    }
                } else {
                    for (int i = 0; i < scoreNum; i++) {
                        cellValueList.add(".");
                    }
                }

                if (var.featureValues != null) {
                    for (int i = 0; i < featureNum; i++) {
                        cellValueList.add(var.featureValues[i]);
                    }
                } else {
                    for (int i = 0; i < featureNum; i++) {
                        cellValueList.add(".");
                    }
                }
                contens.add(cellValueList.toArray(new String[cellValueList.size()]));
            }
        }
        return contens;
    }

    private List<String[]> makeVariantTableList(int chromIndex, boolean needHead, boolean outAltAf) {
        List<String[]> contens = new ArrayList<String[]>();
        if (needHead) {
            List<String> colNumNameList = new ArrayList<String>();
            colNumNameList.add("Chromosome");
            colNumNameList.add("StartPosition");
            colNumNameList.add("ReferenceAlternativeAllele");
            colNumNameList.add("rsID");
            colNumNameList.add("MostImportantFeatureGene");
            colNumNameList.add("MostImportantGeneFeature");
            if (refSeqAnnot) {
                colNumNameList.add("RefGeneFeatures");
            }
            if (gencodeAnnot) {
                colNumNameList.add("GENCODEFeatures");
            }

            if (knownAnnot) {
                colNumNameList.add("UCSCKnownGeneFeatures");
            }
            if (ensemblAnnot) {
                colNumNameList.add("EnsemblFeatures");
            }
            if (needAccoundAffect) {
                colNumNameList.add("AffectedRefHomGtyNum");
                colNumNameList.add("AffectedHetGtyNum");
                colNumNameList.add("AffectedAltHomGtyNum");
            }
            if (needAccoundUnaffect) {
                colNumNameList.add("UnaffectedRefHomGtyNum");
                colNumNameList.add("UnaffectedHetGtyNum");
                colNumNameList.add("UnaffectedAltHomGtyNum");
            }
            if (needAccoundAll) {
                colNumNameList.add("AllRefHomGtyNum");
                colNumNameList.add("AllHetGtyNum");
                colNumNameList.add("AllAltHomGtyNum");
            }

            if (outAltAf) {
                colNumNameList.add("MaxDBAltAF");
            }

            if (variantScoreLabels != null) {
                colNumNameList.addAll(variantScoreLabels);
            }
            if (variantFeatureLabels != null) {
                colNumNameList.addAll(variantFeatureLabels);
            }
            contens.add(colNumNameList.toArray(new String[colNumNameList.size()]));
        }

        int index = 0;
        int scoreNum = 0;
        int featureNum = 0;
        StringBuilder sb = new StringBuilder();
        if (variantScoreLabels != null) {
            scoreNum = variantScoreLabels.size();
        }
        if (variantFeatureLabels != null) {
            featureNum = variantFeatureLabels.size();
        }
        List<String> cellValueList = new ArrayList<String>();

        if (chromosomes[chromIndex] == null) {
            return contens;
        }
        for (Variant var : chromosomes[chromIndex].variantList) {
            cellValueList.clear();

            //format:  chr1 1158631 A/C/G/T rs 
            cellValueList.add(chromosomes[chromIndex].getName());
            cellValueList.add(String.valueOf(var.refStartPosition));

            sb.append(var.getRefAllele());
            for (String alle : var.getAltAlleles()) {
                sb.append('/');
                sb.append(alle);
            }
            cellValueList.add(sb.toString());
            sb.delete(0, sb.length());
            cellValueList.add(var.getLabel());
            cellValueList.add(var.geneSymb);
            cellValueList.add(org.cobi.kggseq.Constants.VAR_FEATURE_NAMES[var.smallestFeatureID]);
            if (refSeqAnnot) {
                cellValueList.add(var.getRefGeneAnnot());
            }
            if (gencodeAnnot) {
                cellValueList.add(var.getgEncodeAnnot());
            }
            if (knownAnnot) {
                cellValueList.add(var.getKnownGeneAnnot());
            }
            if (ensemblAnnot) {
                cellValueList.add(var.getEnsemblGeneAnnot());
            }
            if (needAccoundAffect) {
                cellValueList.add(String.valueOf(var.getAffectedRefHomGtyNum()));
                cellValueList.add(String.valueOf(var.getAffectedHetGtyNum()));
                cellValueList.add(String.valueOf(var.getAffectedAltHomGtyNum()));

            }
            if (needAccoundUnaffect) {
                cellValueList.add(String.valueOf(var.getUnaffectedRefHomGtyNum()));
                cellValueList.add(String.valueOf(var.getUnaffectedHetGtyNum()));
                cellValueList.add(String.valueOf(var.getUnaffectedAltHomGtyNum()));
            }
            if (needAccoundAll) {
                cellValueList.add(String.valueOf(var.getAffectedRefHomGtyNum()));
                cellValueList.add(String.valueOf(var.getAffectedHetGtyNum()));
                cellValueList.add(String.valueOf(var.getAffectedAltHomGtyNum()));
            }

            if (outAltAf) {
                if (var.altAF == -1) {
                    cellValueList.add("N");
                } else if (Float.isNaN(var.altAF)) {
                    cellValueList.add(".");
                } else {
                    cellValueList.add(String.valueOf(var.altAF));
                }

            }

            if (var.scores != null) {
                for (double sc : var.scores) {
                    if (Double.isNaN(sc)) {
                        cellValueList.add(".");
                    } else {
                        cellValueList.add(String.valueOf(sc));
                    }
                }
            } else {
                for (int i = 0; i < scoreNum; i++) {
                    cellValueList.add(".");
                }
            }

            if (var.featureValues != null) {
                for (int i = 0; i < featureNum; i++) {
                    cellValueList.add(var.featureValues[i]);
                }
            } else {
                for (int i = 0; i < featureNum; i++) {
                    cellValueList.add(".");
                }
            }
            contens.add(cellValueList.toArray(new String[cellValueList.size()]));
        }

        return contens;
    }

    private List<String[]> makemRNATableList() {
        int socreNum = geneScoreLabels.size();
        int featureNum = geneFeatureLabels.size();
        int altAfColumn = 0;

        int colNum = 5 + altAfColumn + socreNum + featureNum;
        String[] titleNames = new String[colNum];
        int avaibleColNum = 5 + altAfColumn + socreNum;
        titleNames[0] = "mRNAID";
        titleNames[1] = "GeneSymbol";
        titleNames[2] = "Chromosome";
        titleNames[3] = "StartPosition";
        titleNames[4] = "EndPosition";

        for (int i = 0; i < socreNum; i++) {
            titleNames[i + 5 + altAfColumn] = geneScoreLabels.get(i);
        }
        for (int i = 0; i < featureNum; i++) {
            titleNames[i + 5 + altAfColumn + socreNum] = geneFeatureLabels.get(i);
        }

        int index = 0;
        StringBuilder sb = new StringBuilder();
        List<String[]> contens = new ArrayList<String[]>();
        contens.add(titleNames);
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (mRNA mrna : chromosomes[chromIndex].mRNAList) {
                String[] cells = new String[colNum];
                //format:  chr1 1158531 A/C/G/T rs
                cells[0] = mrna.refID;
                cells[1] = mrna.geneSymb;
                cells[2] = chromosomes[chromIndex].getName();
                cells[3] = String.valueOf(mrna.start);
                cells[4] = String.valueOf(mrna.end);

                avaibleColNum = 5 + altAfColumn;
                if (mrna.testValues != null) {
                    for (double sc : mrna.testValues) {
                        cells[avaibleColNum] = (String.valueOf(sc));
                        avaibleColNum++;
                    }
                }
                avaibleColNum = 5 + socreNum + altAfColumn;
                if (mrna.featureValues != null) {
                    for (String val : mrna.featureValues) {
                        cells[avaibleColNum] = (val);
                        avaibleColNum++;
                    }

                }
                contens.add(cells);
            }
        }

        return contens;
    }

    private List<String[]> makemRNAVariantsTableList(boolean outAltAf) throws Exception {
        int mRNASocreNum = geneScoreLabels.size();
        int mRNAfeatureNum = geneFeatureLabels.size();
        int altAfColumn = 0;

        int varSocreNum = variantScoreLabels.size();
        int varFeatureNum = variantFeatureLabels.size();

        if (outAltAf) {
            altAfColumn = 1;
        }

        int colNum = 5 + mRNASocreNum + mRNAfeatureNum + 4 + altAfColumn + varSocreNum + varFeatureNum;
        String[] titleNames = new String[colNum];
        int avaiblemRNAColNum = 5 + mRNASocreNum;
        int totailmRNAColumn = 5 + mRNASocreNum + mRNAfeatureNum;
        titleNames[0] = "mRNAID";
        titleNames[1] = "GeneSymbol";
        titleNames[2] = "Chromosome";
        titleNames[3] = "mRNAStartPosition";
        titleNames[4] = "mRNAEndPosition";

        for (int i = 0; i < mRNASocreNum; i++) {
            titleNames[i + 5] = geneScoreLabels.get(i);
        }
        for (int i = 0; i < mRNAfeatureNum; i++) {
            titleNames[i + 5 + mRNASocreNum] = geneFeatureLabels.get(i);
        }

        titleNames[totailmRNAColumn] = "VarStartPosition";
        titleNames[totailmRNAColumn + 1] = "ReferenceAlternativeAllele";
        titleNames[totailmRNAColumn + 2] = "GeneFeatures";
        titleNames[totailmRNAColumn + 3] = "GeneFeature";
        if (outAltAf) {
            titleNames[totailmRNAColumn + 4] = "MaxDBAltAF";
        }

        for (int i = 0; i < varSocreNum; i++) {
            titleNames[totailmRNAColumn + i + 4 + altAfColumn] = variantScoreLabels.get(i);

        }

        for (int i = 0; i < varFeatureNum; i++) {
            titleNames[totailmRNAColumn + i + 4 + altAfColumn + varSocreNum] = variantFeatureLabels.get(i);
        }

        int avaibleColNum = 0;
        int index = 0;
        StringBuilder sb = new StringBuilder();
        List<String[]> contens = new ArrayList<String[]>();
        contens.add(titleNames);
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (mRNA mrna : chromosomes[chromIndex].mRNAList) {
                String[] cells = new String[colNum];
                //format:  chr1 1158531 A/C/G/T rs
                cells[0] = mrna.refID;
                cells[1] = mrna.geneSymb;
                cells[2] = chromosomes[chromIndex].getName();
                cells[3] = String.valueOf(mrna.start);
                cells[4] = String.valueOf(mrna.end);

                avaiblemRNAColNum = 5;
                if (mrna.testValues != null) {
                    for (double sc : mrna.testValues) {
                        cells[avaiblemRNAColNum] = (String.valueOf(sc));
                        avaiblemRNAColNum++;
                    }
                }
                avaiblemRNAColNum = 5 + mRNASocreNum;
                if (mrna.featureValues != null) {
                    for (String val : mrna.featureValues) {
                        cells[avaiblemRNAColNum] = (val);
                        avaiblemRNAColNum++;
                    }

                }

                Variant[] vars = lookupVariants(chromosomes[chromIndex].getName(), mrna.start, mrna.end);
                if (vars == null) {
                    contens.add(cells);
                    continue;
                }
                for (int i = 0; i < vars.length; i++) {
                    Variant var = vars[i];
                    if (i > 0) {
                        cells = new String[colNum];
                        cells[1] = mrna.geneSymb;
                    }
                    //format:  chr1 1158631 A/C/G/T rs 
                    cells[totailmRNAColumn] = String.valueOf(var.refStartPosition);

                    sb.append(var.getRefAllele());
                    for (String alle : var.getAltAlleles()) {
                        sb.append('/');
                        sb.append(alle);
                    }
                    cells[totailmRNAColumn + 1] = sb.toString();
                    // if (mrna.geneSymb==null||!mrna.geneSymb.startsWith("HLA")) continue;

                    sb.delete(0, sb.length());
                    cells[totailmRNAColumn + 2] = var.getLabel();
                    cells[totailmRNAColumn + 3] = org.cobi.kggseq.Constants.VAR_FEATURE_NAMES[var.smallestFeatureID];

                    if (outAltAf) {
                        if (var.altAF == -1) {
                            cells[totailmRNAColumn + 4] = "N";
                        } else if (Float.isNaN(var.altAF)) {
                            cells[totailmRNAColumn + 4] = ".";
                        } else {
                            cells[totailmRNAColumn + 4] = String.valueOf(var.altAF);
                        }
                    }
                    avaibleColNum = totailmRNAColumn + 4 + altAfColumn;
                    if (var.scores != null) {
                        for (double sc : var.scores) {
                            cells[avaibleColNum] = (String.valueOf(sc));
                            avaibleColNum++;
                        }
                    }
                    avaibleColNum = totailmRNAColumn + 4 + altAfColumn + varSocreNum;
                    if (var.featureValues != null) {
                        for (String val : var.featureValues) {
                            cells[avaibleColNum] = (val);
                            avaibleColNum++;
                        }
                    }
                    contens.add(cells);
                }

            }
        }

        return contens;
    }

    public void export2ExelFile(String exportPath, boolean altAf) throws Exception {
        List<String[]> contens = null;
        if (geneNum > 0 && varNum > 0) {
            contens = makemRNAVariantsTableList(altAf);
            LocalExcelFile.writeArray2XLSXFile(exportPath, contens, true, 1);
            // LocalExcelFile.writeArray2ExcelFile(exportPath, contens, true, 1);
        } else if (varNum > 0) {
            contens = makeVariantTableList(altAf);
            LocalExcelFile.writeArray2XLSXFile(exportPath, contens, true, 4);
            // LocalExcelFile.writeArray2ExcelFile(exportPath, contens, true, 1);
        } else if (geneNum > 0) {
            contens = makemRNATableList();

        }
    }

    public void export2ExelFile(String exportPath, int chromID, boolean needHead, boolean altAf) throws Exception {
        List<String[]> contens = null;
        if (geneNum > 0 && varNum > 0) {
            contens = makeVariantTableList(chromID, needHead, altAf);
            LocalExcelFile.writeArray2XLSXFile(exportPath, contens, needHead, 1);
            // LocalExcelFile.writeArray2ExcelFile(exportPath, contens, true, 1);
        } else if (varNum > 0) {
            contens = makeVariantTableList(chromID, needHead, altAf);
            LocalExcelFile.appendArray2XLSXFile(exportPath, contens, needHead, 4);
            // LocalExcelFile.writeArray2ExcelFile(exportPath, contens, true, 1);
        } else if (geneNum > 0) {
            contens = makemRNATableList();

        }
    }

    public void export2FlatText(String exportPath, boolean altAf) throws Exception {
        List<String[]> contens = null;
        if (geneNum > 0 && varNum > 0) {
            contens = makemRNAVariantsTableList(altAf);
            LocalFile.writeData(exportPath, contens, "\t", false);
        } else if (varNum > 0) {
            contens = makeVariantTableList(altAf);
            LocalFile.writeData(exportPath, contens, "\t", false);
        } else if (geneNum > 0) {
            contens = makemRNATableList();
            LocalFile.writeData(exportPath, contens, "\t", false);
        } else {
            String info = "No sequence variant(s) or gene(s) left!";
            System.out.println(info);
        }
    }

    public void export2ATmpFormat(BufferedWriter bw, int chromIndex) throws Exception {
        if (chromosomes[chromIndex] == null) {
            return;
        }
        for (Variant var : chromosomes[chromIndex].variantList) {
            /*
             gene	classification	type	chr	pos	ref_allele	newbase
             NFASC	SNP	Missense_Mutation	1	204939750	C	T
             MSRB2	SNP	Splice_site	10	23393074	G	A
             KIAA1462	SNP	Missense_Mutation	10	30317023	C	G
             PRKCQ	SNP	Silent	10	6527124	C	T
             C10orf62	SNP	Missense_Mutation	10	99350211	G	A
             DDX10	SNP	Missense_Mutation	11	108546431	A	G
             OR52M1	SNP	Missense_Mutation	11	4566854	G	A
             KRT1	SNP	Missense_Mutation	12	53071954	A	T
             RNF17	SNP	Missense_Mutation	13	25404700	G	A
             RTN1	SNP	Silent	14	60194064	C	T
             ATP2A1	SNP	Splice_site	16	28898595	G	A
             TP53	SNP	Missense_Mutation	17	7577121	G	A              
             */

            int hetNum = var.getAffectedHetGtyNum();
            int refHomNum = var.getAffectedRefHomGtyNum();
            int altHomNum = var.getAffectedAltHomGtyNum();
            if (refHomNum < altHomNum) {
                continue;
            }
            if (var.isIndel) {
                continue;
            }
            //only singleton
            if (hetNum + altHomNum * 2 > 1) {
                continue;
            }

            for (String altAllele : var.getAltAlleles()) {
                for (int i = 0; i < hetNum; i++) {
                    bw.write(chromosomes[chromIndex].getName());
                    bw.write("\t");
                    bw.write(String.valueOf(var.refStartPosition));
                    bw.write("\t");
                    bw.write(var.getRefAllele());
                    bw.write("\t");
                    bw.write(altAllele);
                    bw.write("\t");
                    bw.write("SNP\n");
                }
                for (int i = 0; i < altHomNum; i++) {
                    bw.write(chromosomes[chromIndex].getName());
                    bw.write("\t");
                    bw.write(String.valueOf(var.refStartPosition));
                    bw.write("\t");
                    bw.write(var.getRefAllele());
                    bw.write("\t");
                    bw.write(altAllele);
                    bw.write("\t");
                    bw.write("SNP\n");
                }
                for (int i = 0; i < altHomNum; i++) {
                    bw.write(chromosomes[chromIndex].getName());
                    bw.write("\t");
                    bw.write(String.valueOf(var.refStartPosition));
                    bw.write("\t");
                    bw.write(var.getRefAllele());
                    bw.write("\t");
                    bw.write(altAllele);
                    bw.write("\t");
                    bw.write("SNP\n");
                }
            }
        }

    }

    public void export2ANNOVARInput(BufferedWriter bw, int chromIndex) throws Exception {
        int signNum = 0;
        if (chromosomes[chromIndex] == null) {
            return;
        }
        for (Variant var : chromosomes[chromIndex].variantList) {
            /*
             * Chr	Start	End	Ref	Obs	Comments
             1	84647761	84647761	C	T	comments: rs6576700 or SNP_A-1780419, a SNP in Affymetrix SNP arrays
             1	13133880	13133881	TC	-	comments: rs59770105, a 2-bp deletion
             1	11326183	11326183	-	AT	comments: rs35561142, a 2-bp insertion
             1	105293754	105293754	A	ATAAA	comments: rs10552169, a block substitution
             13	19695176	20003944	0	-	comments: a 342kb deletion encompassing GJB6, associated with hearing loss                
             */

            for (String altAllele : var.getAltAlleles()) {
                bw.write(chromosomes[chromIndex].getName());
                bw.write(" ");

                if (var.isIndel) {
                    signNum = 0;
                    if (altAllele.charAt(0) == '+') {
                        for (int t = 0; t < altAllele.length(); t++) {
                            if (altAllele.charAt(t) == '+') {
                                signNum++;
                            } else {
                                break;
                            }
                        }
                        signNum--;
                        bw.write(String.valueOf(var.refStartPosition + signNum));
                        bw.write(" ");
                        bw.write(String.valueOf(var.refStartPosition + signNum));
                        bw.write(" ");
                        bw.write("-");
                        bw.write(" ");
                        bw.write(altAllele.substring(signNum + 1));
                    } else if (altAllele.charAt(altAllele.length() - 1) == '+') {
                        bw.write(String.valueOf(var.refStartPosition));
                        bw.write(" ");
                        bw.write(String.valueOf(var.refStartPosition));
                        bw.write(" ");
                        bw.write("-");
                        bw.write(" ");
                        bw.write(altAllele.substring(1));
                    } else if (altAllele.charAt(altAllele.length() - 1) == '-') {
                        for (int t = 0; t < altAllele.length(); t++) {
                            if (altAllele.charAt(t) != '-') {
                                signNum++;
                            } else {
                                break;
                            }
                        }

                        bw.write(String.valueOf(var.refStartPosition + signNum));
                        bw.write(" ");
                        bw.write(String.valueOf(var.refStartPosition + altAllele.length() - 1));
                        bw.write(" ");
                        bw.write(var.getRefAllele().substring(signNum));
                        bw.write(" ");
                        bw.write("-");
                    } else if (altAllele.charAt(0) == '-') {
                        for (int t = 0; t < altAllele.length(); t++) {
                            if (altAllele.charAt(t) == '-') {
                                signNum++;
                            } else {
                                break;
                            }
                        }

                        bw.write(String.valueOf(var.refStartPosition + 1));
                        bw.write(" ");
                        bw.write(String.valueOf(var.refStartPosition + signNum));
                        bw.write(" ");
                        bw.write(var.getRefAllele().substring(0, signNum));
                        bw.write(" ");
                        bw.write("-");
                    }

                } else {
                    bw.write(String.valueOf(var.refStartPosition));
                    bw.write(" ");
                    bw.write(String.valueOf(var.refStartPosition));
                    bw.write(" ");
                    bw.write(String.valueOf(var.getRefAllele()));
                    bw.write(" ");
                    bw.write(altAllele);
                }

                bw.write("\n");
            }
        }

        bw.close();
    }

    public void addVariant(String chromName, Variant var) {
        if (chromName.startsWith(UNKNOWN_CHROM_NAME0) || chromName.startsWith(UNKNOWN_CHROM_NAME1)) {
            return;
        }
        Integer chromID = chromNameIndexMap.get(chromName);
        if (chromID == null) {
            System.err.println("Unrecognized chromosome name: " + chromName);
            return;
        }
        chromosomes[chromID].variantList.add(var);
    }

    public void export2VCFFormat(BufferedWriter bw, int chromIndex, List<Individual> subjectList, String misingGty) throws Exception {
        int signNum = 0;
        if (chromosomes[chromIndex] == null) {
            return;
        }
        StringBuilder sb = new StringBuilder();
        String str = null;
        int index = 0;
        for (Variant var : chromosomes[chromIndex].variantList) {
            /*
             #CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	110105.r	110106.r
             chr1	4770	rs6682375	A	G	49.03	LowQual	AC=2;AF=0.50;AN=4;BaseQRankSum=2.452;DB;DP=14;Dels=0.00;HRun=1;HaplotypeScore=0.0000;MQ=22.20;MQ0=4;MQRankSum=0.107;QD=3.50;ReadPosRankSum=-1.386;SB=3.00	GT:AD:DP:GQ:PL	0/1:7,1:8:15.65:16,0,83	0/1:3,3:6:51.22:68,0,51
             chr1	4793	rs6682385	A	G	111.48	PASS	AC=2;AF=0.50;AN=4;BaseQRankSum=-2.781;DB;DP=19;Dels=0.00;HRun=0;HaplotypeScore=0.4789;MQ=23.62;MQ0=2;MQRankSum=-0.830;QD=5.87;ReadPosRankSum=1.025;SB=5.68	GT:AD:DP:GQ:PL	0/1:7,1:8:9.64:10,0,129	0/1:5,6:11:89.93:136,0,90
             chr1	59133	.	A	G	187.28	PASS	AC=4;AF=1.00;AN=4;BaseQRankSum=-Infinity;DP=100;DS;Dels=0.00;HRun=0;HaplotypeScore=0.0000;MQ=6.88;MQ0=84;MQRankSum=-Infinity;QD=1.87;ReadPosRankSum=-Infinity;SB=-0.01	GT:AD:DP:GQ:PL	1/1:36,14:50:8.98:71,9,0	1/1:37,13:50:17.97:152,18,0
             chr1	59374	rs2691305	A	G	1397.71	PASS	AC=4;AF=1.00;AN=4;BaseQRankSum=1.047;DB;DP=100;DS;Dels=0.00;HRun=0;HaplotypeScore=9.5486;MQ=23.21;MQ0=14;MQRankSum=-1.732;QD=13.98;ReadPosRankSum=-1.692;SB=-467.58	GT:AD:DP:GQ:PL	1/1:1,49:50:77.97:699,78,0	1/1:0,50:50:83.92:735,84,0
             chr1	690515	.	A	G	33.62	LowQual	AC=2;AF=0.50;AN=4;BaseQRankSum=0.555;DP=57;Dels=0.00;HRun=3;HaplotypeScore=0.0000;MQ=13.31;MQ0=45;MQRankSum=-0.185;QD=0.59;ReadPosRankSum=-0.740;SB=-0.01	GT:AD:DP:GQ:PL	0/1:34,2:37:46.93:47,0,120	0/1:19,1:20:21.40:21,0,99
             chr1	714050	.	G	C	10.43	LowQual	AC=1;AF=0.50;AN=2;BaseQRankSum=-Infinity;DP=3;Dels=0.00;HRun=0;HaplotypeScore=0.0000;MQ=21.36;MQ0=2;MQRankSum=-Infinity;QD=3.48;ReadPosRankSum=-Infinity;SB=-0.01	GT:AD:DP:GQ:PL	0/1:2,1:3:1.76:40,3,0	./.
             chr1	714082	.	A	C	10.43	LowQual	AC=1;AF=0.50;AN=2;BaseQRankSum=-Infinity;DP=2;Dels=0.00;HRun=1;HaplotypeScore=0.0000;MQ=26.16;MQ0=1;MQRankSum=-Infinity;QD=5.21;ReadPosRankSum=-Infinity;SB=-0.01	GT:AD:DP:GQ:PL	0/1:1,1:2:1.76:40,3,0	./.
             */

            bw.write(chromosomes[chromIndex].getName());
            bw.write("\t");
            bw.write(String.valueOf(var.refStartPosition));
            bw.write("\t");
            bw.write(var.getLabel());
            bw.write("\t");
            bw.write(var.getRefAllele());
            bw.write("\t");
            sb.delete(0, sb.length());

            for (String altAllele : var.getAltAlleles()) {
                if (var.isIndel) {
                    signNum = 0;
                    if (altAllele.charAt(0) == '+') {
                        for (int t = 0; t < altAllele.length(); t++) {
                            if (altAllele.charAt(t) == '+') {
                                signNum++;
                            } else {
                                break;
                            }
                        }
                        sb.append(var.getRefAllele());
                        sb.append(altAllele.substring(signNum));
                    } else if (altAllele.charAt(altAllele.length() - 1) == '+') {
                        index = altAllele.indexOf('+');
                        if (index >= 0) {
                            sb.append(altAllele.substring(0, index));
                        }
                        sb.append(var.getRefAllele());
                    } else if (altAllele.charAt(altAllele.length() - 1) == '-') {
                        for (int t = 0; t < altAllele.length(); t++) {
                            if (altAllele.charAt(t) != '-') {
                                signNum++;
                            } else {
                                break;
                            }
                        }

                        sb.append(altAllele.substring(0, signNum));
                    } else if (altAllele.charAt(0) == '-') {
                        for (int t = 0; t < altAllele.length(); t++) {
                            if (altAllele.charAt(t) == '-') {
                                signNum++;
                            } else {
                                break;
                            }
                        }
                        sb.append(var.getRefAllele().substring(0, signNum));
                    }

                } else {
                    sb.append(altAllele);
                }
                sb.append(',');
            }
            bw.write(sb.substring(0, sb.length() - 1));
            if (var.getVcfInfor() != null) {
                bw.write(var.getVcfInfor());
            }

            for (Individual indiv : subjectList) {
                bw.write("\t");
                str = indiv.markerGtySetArray[chromIndex].detailedGtyQual[var.genotypeIndex];
                bw.write(str == null ? misingGty : str);
            }
            bw.write("\n");
        }

    }

    public void export2FlatText(BufferedWriter bw, int chromID, boolean needHead, boolean altAf) throws Exception {
        List<String[]> contens = null;
        if (!chromosomes[chromID].mRNAList.isEmpty() && !chromosomes[chromID].variantList.isEmpty()) {
            contens = makemRNAVariantsTableList(altAf);
            LocalFile.writeData(bw, contens, "\t");
        } else if (!chromosomes[chromID].variantList.isEmpty()) {
            contens = makeVariantTableList(chromID, needHead, altAf);
            LocalFile.writeData(bw, contens, "\t");
        } else if (geneNum > 0) {
            contens = makemRNATableList();
            LocalFile.writeData(bw, contens, "\t");
        } else {
            // String info = "No sequence variant(s) or gene(s) left!";
            //System.out.println(info);
        }
    }

    public void export2FlatTextPlink(List<Individual> subjectList, String exportPath) throws Exception {
        BufferedWriter bwMap = new BufferedWriter(new FileWriter(exportPath + ".map"));
        BufferedWriter bwPed = new BufferedWriter(new FileWriter(exportPath + ".ped"));
        int varsNum = 0;
        int indivNum = 0;
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                if (var.genotypeIndex < 0) {
                    continue;
                }
                bwMap.write(chromosomes[chromIndex].getName());
                bwMap.write("\t");
                if (var.getLabel() == null) {
                    bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                } else {
                    String label = var.getLabel();
                    if (label.startsWith("rs")) {
                        bwMap.write(label + "\t");
                    } else {
                        bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                    }
                }
                bwMap.write("0\t");
                bwMap.write(String.valueOf(var.refStartPosition));
                bwMap.write("\n");
                varsNum++;
            }
        }
        bwMap.close();

        int[] gtys = null;
        int bitIndexEx;

        for (Individual indiv : subjectList) {
            if (indiv == null) {
                continue;
            }
            indivNum++;
            bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                    + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
            for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
                if (chromosomes[chromIndex] == null) {
                    continue;
                }
                OpenIntIntHashMap indexMap = vCFBitGtySetting[chromIndex].gtyPos2bitIndexMap;

                for (Variant var : chromosomes[chromIndex].variantList) {
                    if (var.genotypeIndex < 0) {
                        continue;
                    }
                    bitIndexEx = indexMap.get(var.genotypeIndex);
                    bwPed.write(" ");
                    if (isPhasedGty) {
                        gtys = indiv.markerGtySetArray[chromIndex].getPhasedGtyAt(var.genotypeIndex, bitIndexEx, var.getAltAlleles().length + 1);
                    } else {
                        gtys = indiv.markerGtySetArray[chromIndex].getUnphasedGtyAt(var.genotypeIndex, bitIndexEx, var.getAltAlleles().length + 1);
                    }

                    if (gtys == null) {
                        bwPed.write("0 0");
                    } else {
                        if (gtys[0] == 0) {
                            bwPed.write(String.valueOf(var.getRefAllele()));
                        } else {
                            bwPed.write(var.getAltAlleles()[gtys[0] - 1]);
                        }
                        bwPed.write(" ");
                        if (gtys[1] == 0) {
                            bwPed.write(String.valueOf(var.getRefAllele()));
                        } else {
                            bwPed.write(var.getAltAlleles()[gtys[1] - 1]);
                        }
                    }
                    //for test
                    // bwPed.write(var.refStartPosition + "\n");
                }
            }
            bwPed.write("\n");
        }
        bwPed.close();

        String info = "Genotype of " + varsNum + " sequence variant(s) and " + indivNum
                + " individuals are saved \nin " + exportPath + ".map " + exportPath + ".ped  with Plink pedigree format.";
        System.out.println(info);
    }

    public void export2FlatTextPlink(List<Individual> subjectList, VCFBitGtySetting[] vcfFBitGtySetting, Genome refGenome, List<Individual> refSubjectList, String exportPath) throws Exception {
        BufferedWriter bwMap = new BufferedWriter(new FileWriter(exportPath + ".merged.map"));
        BufferedWriter bwPed = new BufferedWriter(new FileWriter(exportPath + ".merged.ped"));
        int varsNum = 0;
        int indivNum = 0;
        boolean needFlip = false;

        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                if (var.genotypeIndex < 0) {
                    continue;
                }
                if (var.isIndel) {
                    continue;
                }
                Variant[] vars = refGenome.lookupVariants(STAND_CHROM_NAMES[chromIndex], var.refStartPosition, var.isIndel, var.getRefAllele(), var.getAltAlleles());
                if (vars == null) {
                    continue;
                }
                if (vars[0].genotypeIndex < 0) {
                    continue;
                }
                char altAllele = vars[0].getAltAlleles()[0].charAt(0);
                /*
                 if (Util.getComplementalChar(vars[0].getRefAllele().charAt(0)) == altAllele) {
                 continue;
                 }
                 * 
                 */
                char altAllele1 = var.getAltAlleles()[0].charAt(0);

                if (altAllele == altAllele1 && vars[0].getRefAllele().charAt(0) == var.getRefAllele().charAt(0)) {
                    needFlip = false;
                } else if (altAllele == var.getRefAllele().charAt(0) && vars[0].getRefAllele().charAt(0) == altAllele1) {
                    needFlip = true;
                } else {
                    continue;
                }
                //Important: ingnore the variants with more thant 2 alleles
                if (var.getAltAlleles().length > 1) {
                    continue;
                }

                bwMap.write(chromosomes[chromIndex].getName());
                bwMap.write("\t");
                if (var.getLabel() == null) {
                    bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                } else {
                    String label = var.getLabel();
                    if (label.startsWith("rs")) {
                        bwMap.write(label + "\t");
                    } else {
                        bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                    }
                }
                bwMap.write("0\t");
                bwMap.write(String.valueOf(var.refStartPosition));
                bwMap.write("\n");
                varsNum++;
            }
        }
        bwMap.close();

        int[] gtys = null;
        for (Individual indiv : subjectList) {
            if (indiv == null) {
                continue;
            }
            indivNum++;
            bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                    + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());

            int bitIndexEx;
            for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
                if (chromosomes[chromIndex] == null) {
                    continue;
                }
                OpenIntIntHashMap indexMap = vCFBitGtySetting[chromIndex].gtyPos2bitIndexMap;

                for (Variant var : chromosomes[chromIndex].variantList) {
                    if (var.genotypeIndex < 0) {
                        continue;
                    }
                    if (var.isIndel) {
                        continue;
                    }
                    Variant[] vars = refGenome.lookupVariants(STAND_CHROM_NAMES[chromIndex], var.refStartPosition, var.isIndel, var.getRefAllele(), var.getAltAlleles());
                    if (vars == null) {
                        continue;
                    }
                    if (vars[0].genotypeIndex < 0) {
                        continue;
                    }
                    char altAllele = vars[0].getAltAlleles()[0].charAt(0);
                    /*
                     if (Util.getComplementalChar(vars[0].getRefAllele().charAt(0)) == altAllele) {
                     continue;
                     }
                     * 
                     */
                    char altAllele1 = var.getAltAlleles()[0].charAt(0);

                    if (altAllele == altAllele1 && vars[0].getRefAllele().charAt(0) == var.getRefAllele().charAt(0)) {
                        needFlip = false;
                    } else if (altAllele == var.getRefAllele().charAt(0) && vars[0].getRefAllele().charAt(0) == altAllele1) {
                        needFlip = true;
                    } else {
                        continue;
                    }

                    //Important: ingnore the variants with more thant 2 alleles
                    if (var.getAltAlleles().length > 1) {
                        continue;
                    }
                    bitIndexEx = indexMap.get(var.genotypeIndex);
                    bwPed.write(" ");
                    if (isPhasedGty) {
                        gtys = indiv.markerGtySetArray[chromIndex].getPhasedGtyAt(var.genotypeIndex, bitIndexEx, var.getAltAlleles().length + 1);
                    } else {
                        gtys = indiv.markerGtySetArray[chromIndex].getUnphasedGtyAt(var.genotypeIndex, bitIndexEx, var.getAltAlleles().length + 1);
                    }

                    if (gtys == null) {
                        bwPed.write("0 0");
                    } else {
                        if (gtys[0] == 0) {
                            bwPed.write(String.valueOf(var.getRefAllele()));
                        } else {
                            bwPed.write(var.getAltAlleles()[gtys[0] - 1]);
                        }
                        bwPed.write(" ");
                        if (gtys[1] == 0) {
                            bwPed.write(String.valueOf(var.getRefAllele()));
                        } else {
                            bwPed.write(var.getAltAlleles()[gtys[1] - 1]);
                        }
                    }
                    //for test
                    // bwPed.write(var.refStartPosition + "\n");
                }
            }
            bwPed.write("\n");
        }

        int bitIndexEx;
        boolean isPhasedRefGty = refGenome.isPhasedGty;
        for (Individual indiv : refSubjectList) {
            if (indiv == null) {
                continue;
            }
            indivNum++;
            bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                    + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
            for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
                if (chromosomes[chromIndex] == null) {
                    continue;
                }
                OpenIntIntHashMap indexMap = vCFBitGtySetting[chromIndex].gtyPos2bitIndexMap;
                for (Variant var : chromosomes[chromIndex].variantList) {
                    if (var.genotypeIndex < 0) {
                        continue;
                    }
                    if (var.isIndel) {
                        continue;
                    }
                    Variant[] vars = refGenome.lookupVariants(STAND_CHROM_NAMES[chromIndex], var.refStartPosition, var.isIndel, var.getRefAllele(), var.getAltAlleles());
                    if (vars == null) {
                        continue;
                    }
                    if (vars[0].genotypeIndex < 0) {
                        continue;
                    }
                    char altAllele = vars[0].getAltAlleles()[0].charAt(0);
                    /*
                     if (Util.getComplementalChar(vars[0].getRefAllele().charAt(0)) == altAllele) {
                     continue;
                     }
                     * 
                     */
                    char altAllele1 = var.getAltAlleles()[0].charAt(0);

                    if (altAllele == altAllele1 && vars[0].getRefAllele().charAt(0) == var.getRefAllele().charAt(0)) {
                        needFlip = false;
                    } else if (altAllele == var.getRefAllele().charAt(0) && vars[0].getRefAllele().charAt(0) == altAllele1) {
                        needFlip = true;
                    } else {
                        continue;
                    }
//Important: ingnore the variants with more thant 2 alleles
                    if (var.getAltAlleles().length > 1) {
                        continue;
                    }
                    bitIndexEx = indexMap.get(var.genotypeIndex);
                    bwPed.write(" ");
                    //simply export the genotypes of first variants
                    if (isPhasedRefGty) {
                        gtys = indiv.markerGtySetArray[chromIndex].getPhasedGtyAt(vars[0].genotypeIndex, bitIndexEx, vars[0].getAltAlleles().length + 1);
                    } else {
                        gtys = indiv.markerGtySetArray[chromIndex].getUnphasedGtyAt(vars[0].genotypeIndex, bitIndexEx, vars[0].getAltAlleles().length + 1);
                    }

                    if (gtys == null) {
                        bwPed.write("0 0");
                    } else {
                        //do not need flip as long as all are in forward strand
                        if (gtys[0] == 0) {
                            bwPed.write(String.valueOf(vars[0].getRefAllele()));
                        } else {
                            bwPed.write(vars[0].getAltAlleles()[0]);
                        }
                        bwPed.write(" ");
                        if (gtys[1] == 0) {
                            bwPed.write(String.valueOf(vars[0].getRefAllele()));
                        } else {
                            bwPed.write(vars[0].getAltAlleles()[0]);
                        }
                    }
                    //for test
                    // bwPed.write(var.refStartPosition + "\n");
                }
            }
            bwPed.write("\n");
        }

        bwPed.close();

        String info = "Genotype of " + varsNum + " sequence variant(s) and " + indivNum
                + " individuals are saved \nin " + exportPath + ".merged.map " + exportPath + ".merged.ped  with Plink pedigree format.";
        System.out.println(info);
    }

    public void export2FlatTextPlink1(List<Individual> subjectList, String exportPath) throws Exception {
        BufferedWriter bwMap = new BufferedWriter(new FileWriter(exportPath + ".map"));
        BufferedWriter bwPed = new BufferedWriter(new FileWriter(exportPath + ".ped"));
        int varsNum = 0;
        int indivNum = 0;
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                if (var.genotypeIndex < 0) {
                    continue;
                }
                bwMap.write(chromosomes[chromIndex].getName());
                bwMap.write("\t");
                if (var.getLabel() == null) {
                    bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                } else {
                    String label = var.getLabel();
                    if (label.startsWith("rs")) {
                        bwMap.write(label + "\t");
                    } else {
                        bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                    }
                }
                bwMap.write("0\t");
                bwMap.write(String.valueOf(var.refStartPosition));
                bwMap.write("\n");
                varsNum++;
            }
        }
        bwMap.close();

        int bitIndexEx;
        int[] gtys = null;
        for (Individual indiv : subjectList) {
            if (indiv == null) {
                continue;
            }
            indivNum++;
            bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                    + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
            for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
                if (chromosomes[chromIndex] == null) {
                    continue;
                }
                OpenIntIntHashMap indexMap = vCFBitGtySetting[chromIndex].gtyPos2bitIndexMap;
                for (Variant var : chromosomes[chromIndex].variantList) {
                    if (var.genotypeIndex < 0) {
                        continue;
                    }
                    bitIndexEx = indexMap.get(var.genotypeIndex);
                    bwPed.write(" ");
                    if (isPhasedGty) {
                        gtys = indiv.markerGtySetArray[chromIndex].getPhasedGtyAt(var.genotypeIndex, bitIndexEx, var.getAltAlleles().length + 1);
                    } else {
                        gtys = indiv.markerGtySetArray[chromIndex].getUnphasedGtyAt(var.genotypeIndex, bitIndexEx, var.getAltAlleles().length + 1);
                    }
                    if (gtys == null) {
                        bwPed.write("0 0");
                    } else {
                        if (gtys[0] == 0) {
                            bwPed.write(String.valueOf(var.getRefAllele()));
                        } else {
                            bwPed.write(var.getAltAlleles()[gtys[0] - 1]);
                        }
                        bwPed.write(" ");
                        if (gtys[1] == 0) {
                            bwPed.write(String.valueOf(var.getRefAllele()));
                        } else {
                            bwPed.write(var.getAltAlleles()[gtys[1] - 1]);
                        }
                    }
                    //for test
                    // bwPed.write(var.refStartPosition + "\n");
                }
            }
            bwPed.write("\n");
        }
        bwPed.close();

        String info = "Genotype of " + varsNum + " sequence variant(s) and "
                + indivNum + " individuals are saved \nin " + exportPath + ".map " + exportPath + ".ped  with Plink pedigree format.";
        System.out.println(info);
    }

    /*
     Similar to plink, each binary file set must contain three separate files:
     kggseq.ked      (kggseq binary file, genotype information)
     kggseq.fam      (first six columns of mydata.ped) 
     kggseq.kim      (extended MAP file: two extra cols = allele names) 
     */
    public void exportKGGSeqBinaryGty(Chromosome chromosome, List<Individual> subjectList, VCFBitGtySetting bitGtySetting, FileChannel fileChannel, BufferedWriter bwMap, int[] savedVar) throws Exception {
        if (chromosome == null) {
            return;
        }

        String xx = chromosome.getName();
        for (Variant var : chromosome.variantList) {
            if (var.genotypeIndex < 0) {
                continue;
            }
            bwMap.write(xx);
            bwMap.write("\t");
            if (var.getLabel() == null) {
                bwMap.write("chr" + xx + ":" + var.refStartPosition + "\t");
            } else {
                String label = var.getLabel();
                if (label.startsWith("rs")) {
                    bwMap.write(label + "\t");
                } else {
                    bwMap.write("chr" + xx + ":" + var.refStartPosition + "\t");
                }
            }
            bwMap.write("0\t");
            bwMap.write(String.valueOf(var.refStartPosition));
            bwMap.write("\t");
            bwMap.write(String.valueOf(var.getRefAllele()));
            bwMap.write("\t");
            bwMap.write(var.getAltAlleles()[0]);
            for (int i = 1; i < var.getAltAlleles().length; i++) {
                bwMap.write(",");
                bwMap.write(var.getAltAlleles()[i]);
            }
            bwMap.write("\n");
            savedVar[0]++;
        }

        int bufSize = 1024 * 1024;

        ByteBuffer byteBuffer = ByteBuffer.allocate(bufSize);

        //temperally store the genotype information 
        boolean[] bits = new boolean[2];
        boolean[] exbits = null;
        int base = 0;

        int indivIndex = 8;
        int leftCapcitiy = bufSize;
        int alleleNum = 0;
        OpenIntIntHashMap gtyPos2bitIndexMap = bitGtySetting.gtyPos2bitIndexMap;
        int chromIndex = chromosome.getId();
        int bitIndexEx;
        for (Variant var : chromosome.variantList) {
            if (var.genotypeIndex < 0) {
                continue;
            }
            bitIndexEx = gtyPos2bitIndexMap.get(var.genotypeIndex);
            //very important, it wast me a lot of time to find the problem
            bitIndexEx--;

            alleleNum = var.getAltAlleles().length + 1;

            byte[] gtyBlocks = null;
            if (isPhasedGty) {
                base = GlobalManager.phasedAlleleBitMap.get(alleleNum);
            } else {
                base = GlobalManager.unphasedAlleleBitMap.get(alleleNum);
            }
            gtyBlocks = new byte[base];
            //renew the bytes for each variant
            indivIndex = 8;

            for (Individual indiv : subjectList) {
                if (indiv == null) {
                    continue;
                }
                if (isPhasedGty) {
                    indiv.markerGtySetArray[chromIndex].getPhasedGtyBitAt(var.genotypeIndex, bits, alleleNum);
                } else {
                    exbits = indiv.markerGtySetArray[chromIndex].getUnphasedGtyBitAt(var.genotypeIndex, bitIndexEx, alleleNum, bits);
                }
                for (int s = 0; s < 2; s++) {
                    if (bits[s]) {
                        gtyBlocks[s] = (byte) ((gtyBlocks[s] << 1) | 1);
                    } else {
                        gtyBlocks[s] = (byte) ((gtyBlocks[s] << 1));
                    }
                }
                if (exbits != null) {
                    for (int s = 0; s < exbits.length; s++) {
                        if (exbits[s]) {
                            gtyBlocks[s + 2] = (byte) ((gtyBlocks[s + 2] << 1) | 1);
                        } else {
                            gtyBlocks[s + 2] = (byte) ((gtyBlocks[s + 2] << 1));
                        }
                    }
                }
                indivIndex--;
                if (indivIndex == 0) {
                    byteBuffer.put(gtyBlocks);
                    leftCapcitiy -= gtyBlocks.length;
                    indivIndex = 8;
                    if (leftCapcitiy < gtyBlocks.length) {
                        byteBuffer.flip();
                        fileChannel.write(byteBuffer);
                        byteBuffer.clear();
                        leftCapcitiy = bufSize;
                    }
                    //System.out.println(bytesToHexString(gtyBlocks));
                }
            }
            if (indivIndex != 8) {
                //offset the missing so that the genotypes can start from the fist position
                for (int s = 0; s < gtyBlocks.length; s++) {
                    gtyBlocks[s] = (byte) (gtyBlocks[s] << indivIndex);
                    //System.out.println(end + " : " + BitByteUtil.byteToBinaryString(gtyBlocks[s]));
                    //end++;
                }
                leftCapcitiy -= gtyBlocks.length;
            }
            if (leftCapcitiy != bufSize) {
                byteBuffer.put(gtyBlocks);
                byteBuffer.flip();
                fileChannel.write(byteBuffer);
                byteBuffer.clear();
            }
        }
    }

    /*
     Similar to plink, each binary file set must contain three separate files:
     kggseq.ked      (kggseq binary file, genotype information)
     kggseq.fam      (first six columns of mydata.ped) 
     kggseq.kim      (extended MAP file: two extra cols = allele names) 
     */
    public void exportPlinkBinaryGty(List<Individual> subjectList, String exportPath) throws Exception {
        if (subjectList == null || subjectList.isEmpty()) {
            return;
        }
        File kedFile = new File(exportPath + ".bed");
        if (kedFile.exists()) {
            kedFile.delete();
        }
        RandomAccessFile rafKed = new RandomAccessFile(kedFile, "rw");
        FileChannel fileChannel = rafKed.getChannel();
        BufferedWriter bwPed = new BufferedWriter(new FileWriter(exportPath + ".fam"));
        BufferedWriter bwMap = new BufferedWriter(new FileWriter(exportPath + ".bim"));

        int varsNum = 0;
        int indivNum = 0;

        /*
         *
         * The autosomes should be coded 1 through 22. The following other codes can be used to specify other chromosome types:
        
         X    X chromosome                    -> 23
         Y    Y chromosome                    -> 24
         XY   Pseudo-autosomal region of X    -> 25
         MT   Mitochondrial                   -> 26
        
         */
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                if (var.genotypeIndex < 0) {
                    continue;
                }
                //Important: ingnore the variants with more thant 2 alleles
                if (var.getAltAlleles().length > 1) {
                    continue;
                }
                bwMap.write(String.valueOf(chromIndex + 1));

                bwMap.write("\t");
                if (var.getLabel() == null) {
                    bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                } else {
                    String label = var.getLabel();
                    if (label.startsWith("rs")) {
                        bwMap.write(label + "\t");
                    } else {
                        bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                    }
                }
                bwMap.write("0\t");
                bwMap.write(String.valueOf(var.refStartPosition));
                bwMap.write("\t");
                bwMap.write(String.valueOf(var.getRefAllele()));
                bwMap.write("\t");
                bwMap.write(var.getAltAlleles()[0]);
                bwMap.write("\n");
                varsNum++;
            }
        }
        bwMap.close();

        for (Individual indiv : subjectList) {
            if (indiv == null) {
                continue;
            }
            indivNum++;
            bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                    + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
            bwPed.write("\n");
        }
        bwPed.close();

        int bufSize = 1024;

        ByteBuffer byteBuffer = ByteBuffer.allocate(bufSize);

        //|-magic number-
        //01101100 00011011
        byte byteInfo = (byte) 0x6C;
        byteBuffer.put(byteInfo);
        byteInfo = (byte) 0x1B;
        byteBuffer.put(byteInfo);
        //|-mode-| 00000001 (SNP-major)
        //00000001 
        byteInfo = 1;

        byteBuffer.put(byteInfo);
        byteBuffer.flip();
        fileChannel.write(byteBuffer);
        byteBuffer.clear();

        //temperally store the genotype information 
        boolean[] bits = new boolean[5];
        int indivIndex = 8;
        int leftCapcitiy = bufSize;
        int end = 0;
        byte x;
        /*
         missing	Reference homozygous	Heterozygous 	Alternative homozygous
         VCF genotype	./.	0/0	0/1	1/1
         Bits	        00  	01	10	11
         Order	0	1	2	3        
         */

        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                if (var.genotypeIndex < 0) {
                    continue;
                }
//Important: ingnore the variants with more thant 2 alleles
                if (var.getAltAlleles().length > 1) {
                    continue;
                }


                /*
                 * 00  Homozygote "1"/"1"
                 01  Heterozygote
                 11  Homozygote "2"/"2"
                 10  Missing genotype
                 */
//renew the bytes for each variant, each byte for 4 subjects at most
                indivIndex = 4;
                for (Individual indiv : subjectList) {
                    if (indiv == null) {
                        continue;
                    }

                    if (isPhasedGty) {
                        /*
                         missing	Reference homozygous	Heterozygous 	Heterozygous 	Alternative homozygous
                         VCF genotype	.|.	0|0	0|1	1|0	1|1
                         Bits      	000  	001	010	011	100
                         Order	0	1	2	3	4        
                         */
                        indiv.markerGtySetArray[chromIndex].getPhasedGtyBitAt(var.genotypeIndex, bits, 2);
                        //due to over-flow problme we nee this
                        byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                        //Homozygote
                        if (!bits[0] && !bits[1] && bits[2]) {
                        } else if (bits[0] && !bits[1] && !bits[2]) {
                            //Homozygote                          
                            byteInfo = (byte) (byteInfo | 0XC0);
                        } else if ((!bits[0] && bits[1] && !bits[2]) || (!bits[0] && bits[1] && bits[2])) {
                            //Heterozygote
                            //annoyed!!! The plink binary annotation is different from plink excutable tool for the 01 10 definition
                            byteInfo = (byte) (byteInfo | 0X80);
                        } else if (!bits[0] && !bits[1] && !bits[2]) {
                            //missing   
                            byteInfo = (byte) (byteInfo | 0X40);
                        }
                    } else {
                        //to be modified
                        // indiv.markerGtySetArray[chromIndex].getUnphasedGtyBitAt(var.genotypeIndex, bits, 2);
                        //due to over-flow problme we nee this
                        byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                        //Homozygote
                        if (!bits[0] && bits[1]) {
                        } else if (bits[0] && bits[1]) {
                            //Homozygote                          
                            byteInfo = (byte) (byteInfo | 0XC0);
                        } else if (bits[0] && !bits[1]) {
                            //Heterozygote
                            //annoyed!!! The plink binary annotation is different from plink excutable tool for the 01 10 definition
                            byteInfo = (byte) (byteInfo | 0X80);
                        } else if (!bits[0] && !bits[1]) {
                            //missing   
                            byteInfo = (byte) (byteInfo | 0X40);
                        }
                    }
                    indivIndex--;
                    if (indivIndex == 0) {
                        byteBuffer.put(byteInfo);
                        leftCapcitiy--;
                        indivIndex = 4;
                        if (leftCapcitiy == 0) {
                            byteBuffer.flip();
                            fileChannel.write(byteBuffer);
                            byteBuffer.clear();
                            leftCapcitiy = bufSize;
                        }
                        // if (indID.equals("C")) 
                        //System.out.println(BitByteUtil.byteToBinaryString(byteInfo));
                    }
                }
//Subject to debug. do not know why it is not correct
                if (indivIndex != 4) {
                    //offset the missing so that the genotypes can start from the fist position 
                    //for (int i=0;i<indivIndex;i++) byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                    byteInfo = (byte) (byteInfo >>> (indivIndex * 2));
                    // System.out.println(end + " : " + BitByteUtil.byteToBinaryString(byteInfo));
                    //end++; 
                    byteBuffer.put(byteInfo);
                    leftCapcitiy--;
                }
                if (leftCapcitiy != bufSize) {
                    byteBuffer.flip();
                    fileChannel.write(byteBuffer);
                    byteBuffer.clear();
                    leftCapcitiy = bufSize;
                }
            }
        }

        fileChannel.close();
        rafKed.close();
        String info = "Genotype of " + varsNum + " sequence variant(s) and " + indivNum + " individuals are saved \nin "
                + exportPath + ".fam " + exportPath + ".bim " + exportPath + ".bed " + " with Plink binary genotype format.";
        System.out.println(info);
    }

    /*
     Similar to plink, each binary file set must contain three separate files:
     kggseq.ked      (kggseq binary file, genotype information)
     kggseq.fam      (first six columns of mydata.ped) 
     kggseq.kim      (extended MAP file: two extra cols = allele names) 
     */
    public void exportPlinkBinaryGty(Chromosome chromosome, List<Individual> subjectList, VCFBitGtySetting bitGtySetting, BufferedWriter bwMap, FileChannel fileChannel) throws Exception {
        if (subjectList == null || subjectList.isEmpty()) {
            return;
        }
        if (chromosome == null) {
            return;
        }

        int varsNum = 0;
        int indivNum = 0;

        /*
         *
         * The autosomes should be coded 1 through 22. The following other codes can be used to specify other chromosome types:
        
         X    X chromosome                    -> 23
         Y    Y chromosome                    -> 24
         XY   Pseudo-autosomal region of X    -> 25
         MT   Mitochondrial                   -> 26        
         */
        int chromIndex = chromosome.getId();

        for (Variant var : chromosome.variantList) {
            if (var.genotypeIndex < 0) {
                continue;
            }
            //Important: ingnore the variants with more thant 2 alleles
            if (var.getAltAlleles().length > 1) {
                continue;
            }
            bwMap.write(String.valueOf(chromIndex + 1));

            bwMap.write("\t");
            if (var.getLabel() == null) {
                bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
            } else {
                String label = var.getLabel();
                if (label.startsWith("rs")) {
                    bwMap.write(label + "\t");
                } else {
                    bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                }
            }
            bwMap.write("0\t");
            bwMap.write(String.valueOf(var.refStartPosition));
            bwMap.write("\t");
            bwMap.write(String.valueOf(var.getRefAllele()));
            bwMap.write("\t");
            bwMap.write(var.getAltAlleles()[0]);
            bwMap.write("\n");
            varsNum++;
        }

        int bufSize = 1024;

        ByteBuffer byteBuffer = ByteBuffer.allocate(bufSize);

        //|-magic number-
        //01101100 00011011
        byte byteInfo = (byte) 0x6C;
        byteBuffer.put(byteInfo);
        byteInfo = (byte) 0x1B;
        byteBuffer.put(byteInfo);
        //|-mode-| 00000001 (SNP-major)
        //00000001 
        byteInfo = 1;

        byteBuffer.put(byteInfo);
        byteBuffer.flip();
        fileChannel.write(byteBuffer);
        byteBuffer.clear();

        //temperally store the genotype information 
        boolean[] bits = new boolean[5];
        int indivIndex = 8;
        int leftCapcitiy = bufSize;
        int end = 0;
        byte x;
        /*
         missing	Reference homozygous	Heterozygous 	Alternative homozygous
         VCF genotype	./.	0/0	0/1	1/1
         Bits	        00  	01	10	11
         Order	0	1	2	3        
         */
        OpenIntIntHashMap gtyPos2bitIndexMap = bitGtySetting.gtyPos2bitIndexMap;
        int bitIndexEx;
        for (Variant var : chromosome.variantList) {
            if (var.genotypeIndex < 0) {
                continue;
            }
//Important: ingnore the variants with more thant 2 alleles
            if (var.getAltAlleles().length > 1) {
                continue;
            }


            /*
             * 00  Homozygote "1"/"1"
             01  Heterozygote
             11  Homozygote "2"/"2"
             10  Missing genotype
             */
//renew the bytes for each variant, each byte for 4 subjects at most
            indivIndex = 4;
            for (Individual indiv : subjectList) {
                if (indiv == null) {
                    continue;
                }

                if (isPhasedGty) {
                    /*
                     missing	Reference homozygous	Heterozygous 	Heterozygous 	Alternative homozygous
                     VCF genotype	.|.	0|0	0|1	1|0	1|1
                     Bits      	000  	001	010	011	100
                     Order	0	1	2	3	4        
                     */
                    indiv.markerGtySetArray[chromIndex].getPhasedGtyBitAt(var.genotypeIndex, bits, 2);
                    //due to over-flow problme we nee this
                    byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                    //Homozygote
                    if (!bits[0] && !bits[1] && bits[2]) {
                    } else if (bits[0] && !bits[1] && !bits[2]) {
                        //Homozygote                          
                        byteInfo = (byte) (byteInfo | 0XC0);
                    } else if ((!bits[0] && bits[1] && !bits[2]) || (!bits[0] && bits[1] && bits[2])) {
                        //Heterozygote
                        //annoyed!!! The plink binary annotation is different from plink excutable tool for the 01 10 definition
                        byteInfo = (byte) (byteInfo | 0X80);
                    } else if (!bits[0] && !bits[1] && !bits[2]) {
                        //missing   
                        byteInfo = (byte) (byteInfo | 0X40);
                    }
                } else {
                    //to be modified
                    indiv.markerGtySetArray[chromIndex].getUnphasedGtyBitAt(var.genotypeIndex, -1, 2, bits);
                    //due to over-flow problme we nee this
                    byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                    //Homozygote
                    if (!bits[0] && bits[1]) {
                    } else if (bits[0] && bits[1]) {
                        //Homozygote                          
                        byteInfo = (byte) (byteInfo | 0XC0);
                    } else if (bits[0] && !bits[1]) {
                        //Heterozygote
                        //annoyed!!! The plink binary annotation is different from plink excutable tool for the 01 10 definition
                        byteInfo = (byte) (byteInfo | 0X80);
                    } else if (!bits[0] && !bits[1]) {
                        //missing   
                        byteInfo = (byte) (byteInfo | 0X40);
                    }
                }
                indivIndex--;
                if (indivIndex == 0) {
                    byteBuffer.put(byteInfo);
                    leftCapcitiy--;
                    indivIndex = 4;
                    if (leftCapcitiy == 0) {
                        byteBuffer.flip();
                        fileChannel.write(byteBuffer);
                        byteBuffer.clear();
                        leftCapcitiy = bufSize;
                    }
                    // if (indID.equals("C")) 
                    //System.out.println(BitByteUtil.byteToBinaryString(byteInfo));
                }
            }
//Subject to debug. do not know why it is not correct
            if (indivIndex != 4) {
                //offset the missing so that the genotypes can start from the fist position 
                //for (int i=0;i<indivIndex;i++) byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                byteInfo = (byte) (byteInfo >>> (indivIndex * 2));
                // System.out.println(end + " : " + BitByteUtil.byteToBinaryString(byteInfo));
                //end++; 
                byteBuffer.put(byteInfo);
                leftCapcitiy--;
            }
            if (leftCapcitiy != bufSize) {
                byteBuffer.flip();
                fileChannel.write(byteBuffer);
                byteBuffer.clear();
                leftCapcitiy = bufSize;
            }
        }

      
    }

    public void exportPlinkBinaryGty(List<Individual> subjectList, Genome refGenome, List<Individual> refSubjectList, String exportPath) throws Exception {
        if (subjectList == null || subjectList.isEmpty()) {
            return;
        }
        File kedFile = new File(exportPath + ".merged.bed");
        if (kedFile.exists()) {
            kedFile.delete();
        }
        RandomAccessFile rafKed = new RandomAccessFile(kedFile, "rw");
        FileChannel fileChannel = rafKed.getChannel();
        BufferedWriter bwPed = new BufferedWriter(new FileWriter(exportPath + ".merged.fam"));
        BufferedWriter bwMap = new BufferedWriter(new FileWriter(exportPath + ".merged.bim"));

        int varsNum = 0;
        int indivNum = 0;

        boolean needFlip = false;

        /*
         *
         * The autosomes should be coded 1 through 22. The following other codes can be used to specify other chromosome types:
        
         X    X chromosome                    -> 23
         Y    Y chromosome                    -> 24
         XY   Pseudo-autosomal region of X    -> 25
         MT   Mitochondrial                   -> 26
        
         */
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                if (var.genotypeIndex < 0) {
                    continue;
                }
                if (var.isIndel) {
                    continue;
                }
                Variant[] vars = refGenome.lookupVariants(STAND_CHROM_NAMES[chromIndex], var.refStartPosition, var.isIndel, var.getRefAllele(), var.getAltAlleles());
                if (vars == null) {
                    continue;
                }

                if (vars[0].genotypeIndex < 0) {
                    continue;
                }
                char altAllele = vars[0].getAltAlleles()[0].charAt(0);

                /*
                 if (Util.getComplementalChar(vars[0].getRefAllele().charAt(0)) == altAllele) {
                 continue;
                 }
                 * 
                 */
                char altAllele1 = var.getAltAlleles()[0].charAt(0);

                if (altAllele == altAllele1 && vars[0].getRefAllele().charAt(0) == var.getRefAllele().charAt(0)) {
                    needFlip = false;
                } else if (altAllele == var.getRefAllele().charAt(0) && vars[0].getRefAllele().charAt(0) == altAllele1) {
                    needFlip = true;
                } else {
                    continue;
                }

                //Important: ingnore the variants with more thant 2 alleles
                if (var.getAltAlleles().length > 1) {
                    continue;
                }

                bwMap.write(String.valueOf(chromIndex + 1));

                bwMap.write("\t");
                if (var.getLabel() == null) {
                    bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                } else {
                    String label = var.getLabel();
                    if (label.startsWith("rs")) {
                        bwMap.write(label + "\t");
                    } else {
                        bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                    }
                }
                bwMap.write("0\t");
                bwMap.write(String.valueOf(var.refStartPosition));
                bwMap.write("\t");
                bwMap.write(String.valueOf(var.getRefAllele()));
                bwMap.write("\t");
                bwMap.write(var.getAltAlleles()[0]);
                bwMap.write("\n");
                varsNum++;
            }
        }
        bwMap.close();

        for (Individual indiv : subjectList) {
            if (indiv == null) {
                continue;
            }
            indivNum++;
            bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                    + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
            bwPed.write("\n");
        }

        for (Individual indiv : refSubjectList) {
            if (indiv == null) {
                continue;
            }
            indivNum++;
            bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                    + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
            bwPed.write("\n");
        }

        bwPed.close();

        int bufSize = 1024;

        ByteBuffer byteBuffer = ByteBuffer.allocate(bufSize);

        //|-magic number-
        //01101100 00011011
        byte byteInfo = (byte) 0x6C;
        byteBuffer.put(byteInfo);
        byteInfo = (byte) 0x1B;
        byteBuffer.put(byteInfo);
        //|-mode-| 00000001 (SNP-major)
        //00000001 
        byteInfo = 1;

        byteBuffer.put(byteInfo);
        byteBuffer.flip();
        fileChannel.write(byteBuffer);
        byteBuffer.clear();

        //temperally store the genotype information 
        boolean[] bits = new boolean[5];
        int indivIndex = 8;
        int leftCapcitiy = bufSize;
        int end = 0;
        byte x;
        /*
         missing	Reference homozygous	Heterozygous 	Alternative homozygous
         VCF genotype	./.	0/0	0/1	1/1
         Bits	        00  	01	10	11
         Order	0	1	2	3        
         */

        boolean isPhasedRefGty = refGenome.isPhasedGty;
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                if (var.genotypeIndex < 0) {
                    continue;
                }
                if (var.isIndel) {
                    continue;
                }
                Variant[] vars = refGenome.lookupVariants(STAND_CHROM_NAMES[chromIndex], var.refStartPosition, var.isIndel, var.getRefAllele(), var.getAltAlleles());
                if (vars == null) {
                    continue;
                }
                if (vars[0].genotypeIndex < 0) {
                    continue;
                }
                char altAlleleHap = vars[0].getAltAlleles()[0].charAt(0);
                char refAlleleHap = vars[0].getRefAllele().charAt(0);
                /*
                 if (Util.getComplementalChar(refAlleleHap) == altAlleleHap) {
                 continue;
                 }
                 * 
                 */
                char altAllele1 = var.getAltAlleles()[0].charAt(0);

                if (altAlleleHap == altAllele1 && vars[0].getRefAllele().charAt(0) == var.getRefAllele().charAt(0)) {
                    needFlip = false;
                } else if (altAlleleHap == var.getRefAllele().charAt(0) && vars[0].getRefAllele().charAt(0) == altAllele1) {
                    needFlip = true;
                } else {
                    continue;
                }
//Important: ingnore the variants with more thant 2 alleles
                if (var.getAltAlleles().length > 1) {
                    continue;
                }


                /*
                 * 00  Homozygote "1"/"1"
                 01  Heterozygote
                 11  Homozygote "2"/"2"
                 10  Missing genotype
                 */
//renew the bytes for each variant, each byte for 4 subjects at most
                indivIndex = 4;
                for (Individual indiv : subjectList) {
                    if (indiv == null) {
                        continue;
                    }

                    if (isPhasedGty) {
                        /*
                         missing	Reference homozygous	Heterozygous 	Heterozygous 	Alternative homozygous
                         VCF genotype	.|.	0|0	0|1	1|0	1|1
                         Bits      	000  	001	010	011	100
                         Order	0	1	2	3	4        
                         */
                        indiv.markerGtySetArray[chromIndex].getPhasedGtyBitAt(var.genotypeIndex, bits, 2);
                        //due to over-flow problme we nee this
                        byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                        //Homozygote
                        if (!bits[0] && !bits[1] && bits[2]) {
                        } else if (bits[0] && !bits[1] && !bits[2]) {
                            //Homozygote                          
                            byteInfo = (byte) (byteInfo | 0XC0);
                        } else if ((!bits[0] && bits[1] && !bits[2]) || (!bits[0] && bits[1] && bits[2])) {
                            //Heterozygote
                            //annoyed!!! The plink binary annotation is different from plink excutable tool for the 01 10 definition
                            byteInfo = (byte) (byteInfo | 0X80);
                        } else if (!bits[0] && !bits[1] && !bits[2]) {
                            //missing   
                            byteInfo = (byte) (byteInfo | 0X40);
                        }
                    } else {
//to be modified                        
//indiv.markerGtySetArray[chromIndex].getUnphasedGtyBitAt(var.genotypeIndex, bits, 2);
                        //due to over-flow problme we nee this
                        byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                        //Homozygote
                        if (!bits[0] && bits[1]) {
                        } else if (bits[0] && bits[1]) {
                            //Homozygote                          
                            byteInfo = (byte) (byteInfo | 0XC0);
                        } else if (bits[0] && !bits[1]) {
                            //Heterozygote
                            //annoyed!!! The plink binary annotation is different from plink excutable tool for the 01 10 definition
                            byteInfo = (byte) (byteInfo | 0X80);
                        } else if (!bits[0] && !bits[1]) {
                            //missing   
                            byteInfo = (byte) (byteInfo | 0X40);
                        }
                    }
                    indivIndex--;
                    if (indivIndex == 0) {
                        byteBuffer.put(byteInfo);
                        leftCapcitiy--;
                        indivIndex = 4;
                        if (leftCapcitiy == 0) {
                            byteBuffer.flip();
                            fileChannel.write(byteBuffer);
                            byteBuffer.clear();
                            leftCapcitiy = bufSize;
                        }
                        // if (indID.equals("C")) 
                        //System.out.println(BitByteUtil.byteToBinaryString(byteInfo));
                    }
                }

                for (Individual indiv : refSubjectList) {
                    if (indiv == null) {
                        continue;
                    }

                    if (isPhasedRefGty) {
                        /*
                         missing	Reference homozygous	Heterozygous 	Heterozygous 	Alternative homozygous
                         VCF genotype	.|.	0|0	0|1	1|0	1|1
                         Bits      	000  	001	010	011	100
                         Order	0	1	2	3	4        
                         */
                        indiv.markerGtySetArray[chromIndex].getPhasedGtyBitAt(vars[0].genotypeIndex, bits, 2);
                        //due to over-flow problme we nee this
                        byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                        //Homozygote
                        if (!bits[0] && !bits[1] && bits[2]) {
                            if (needFlip) {
                                byteInfo = (byte) (byteInfo | 0XC0);
                            } else {
                            }
                        } else if (bits[0] && !bits[1] && !bits[2]) {
                            //Homozygote                       
                            if (needFlip) {
                            } else {
                                byteInfo = (byte) (byteInfo | 0XC0);
                            }
                        } else if ((!bits[0] && bits[1] && !bits[2]) || (!bits[0] && bits[1] && bits[2])) {
                            //Heterozygote
                            //annoyed!!! The plink binary annotation is different from plink excutable tool for the 01 10 definition
                            byteInfo = (byte) (byteInfo | 0X80);
                        } else if (!bits[0] && !bits[1] && !bits[2]) {
                            //missing   
                            byteInfo = (byte) (byteInfo | 0X40);
                        }
                    } else {
                        //to be modified
                        //indiv.markerGtySetArray[chromIndex].getUnphasedGtyBitAt(vars[0].genotypeIndex, bits, 2);
                        //due to over-flow problme we nee this
                        byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                        //Homozygote
                        if (!bits[0] && bits[1]) {
                            if (needFlip) {
                                byteInfo = (byte) (byteInfo | 0XC0);
                            } else {
                            }
                        } else if (bits[0] && bits[1]) {
                            //Homozygote                          
                            if (needFlip) {
                            } else {
                                byteInfo = (byte) (byteInfo | 0XC0);
                            }
                        } else if (bits[0] && !bits[1]) {
                            //Heterozygote
                            //annoyed!!! The plink binary annotation is different from plink excutable tool for the 01 10 definition
                            byteInfo = (byte) (byteInfo | 0X80);
                        } else if (!bits[0] && !bits[1]) {
                            //missing   
                            byteInfo = (byte) (byteInfo | 0X40);
                        }
                    }
                    indivIndex--;
                    if (indivIndex == 0) {
                        byteBuffer.put(byteInfo);
                        leftCapcitiy--;
                        indivIndex = 4;
                        if (leftCapcitiy == 0) {
                            byteBuffer.flip();
                            fileChannel.write(byteBuffer);
                            byteBuffer.clear();
                            leftCapcitiy = bufSize;
                        }
                        // if (indID.equals("C")) 
                        //System.out.println(BitByteUtil.byteToBinaryString(byteInfo));
                    }
                }

//Subject to debug. do not know why it is not correct
                if (indivIndex != 4) {
                    //offset the missing so that the genotypes can start from the fist position 
                    //for (int i=0;i<indivIndex;i++) byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                    byteInfo = (byte) (byteInfo >>> (indivIndex * 2));
                    // System.out.println(end + " : " + BitByteUtil.byteToBinaryString(byteInfo));
                    //end++; 
                    byteBuffer.put(byteInfo);
                    leftCapcitiy--;
                }
                if (leftCapcitiy != bufSize) {
                    byteBuffer.flip();
                    fileChannel.write(byteBuffer);
                    byteBuffer.clear();
                    leftCapcitiy = bufSize;
                }
            }
        }

        fileChannel.close();
        rafKed.close();
        String info = "Genotype of " + varsNum + " sequence variant(s) and " + indivNum + " individuals are saved \nin "
                + exportPath + ".merged.fam " + exportPath + ".merged.bim " + exportPath + ".merged.bed " + " with Plink binary genotype format.";
        System.out.println(info);
    }

    /* To be done
     ANCESTRYMAP format:
     genotype file: see example.ancestrymapgeno in this directory
     snp file:      see example.snp
     indiv file:    see example.ind
     Note that
     The genotype file contains 1 line per valid genotype.  There are 3 columns:
     1st column is SNP name
     2nd column is sample ID
     3rd column is number of reference alleles (0 or 1 or 2)
     Missing genotypes are encoded by the absence of an entry in the genotype file.
     The snp file contains 1 line per SNP.  There are 6 columns (last 2 optional):
     1st column is SNP name
     2nd column is chromosome.  X chromosome is encoded as 23.
     Also, Y is encoded as 24, mtDNA is encoded as 90, and XY is encoded as 91.
     Note: SNPs with illegal chromosome values, such as 0, will be removed
     3rd column is genetic position (in Morgans).  If unknown, ok to set to 0.0.
     4th column is physical position (in bases)
     Optional 5th and 6th columns are reference and variant alleles.
     For monomorphic SNPs, the variant allele can be encoded as X (unknown).
     The indiv file contains 1 line per individual.  There are 3 columns:
     1st column is sample ID.  Length is limited to 39 characters, including
     the family name if that will be concatenated.
     2nd column is gender (M or F).  If unknown, ok to set to U for Unknown.
     3rd column is a label which might refer to Case or Control status, or
     might be a population group label.  If this entry is set to "Ignore", 
     then that individual and all genotype data from that individual will be
     removed from the data set in all convertf output.
     The name "ANCESTRYMAP format" is used for historical reasons only.  This
     software is completely independent of our 2004 ANCESTRYMAP software.
    
     EIGENSTRAT format: used by eigenstrat program
     genotype file: see example.eigenstratgeno
     snp file:      see example.snp (same as above)
     indiv file:    see example.ind (same as above)
     Note that
     The genotype file contains 1 line per SNP.  
     Each line contains 1 character per individual:
     0 means zero copies of reference allele.
     1 means one copy of reference allele.
     2 means two copies of reference allele.
     9 means missing data.
     The program ind2pheno.perl in this directory will convert from 
     example.ind to the example.pheno file needed by the EIGENSTRAT software.
     The syntax is "./ind2pheno.perl example.ind example.pheno".
    
     */
    public void exportEigenStratGty(List<Individual> subjectList, String exportPath) throws Exception {
        if (subjectList == null || subjectList.isEmpty()) {
            return;
        }
        File kedFile = new File(exportPath + ".bed");
        if (kedFile.exists()) {
            kedFile.delete();
        }
        RandomAccessFile rafKed = new RandomAccessFile(kedFile, "rw");
        FileChannel fileChannel = rafKed.getChannel();
        BufferedWriter bwPed = new BufferedWriter(new FileWriter(exportPath + ".fam"));
        BufferedWriter bwMap = new BufferedWriter(new FileWriter(exportPath + ".bim"));

        int varsNum = 0;
        int indivNum = 0;

        /*
         *
         * The autosomes should be coded 1 through 22. The following other codes can be used to specify other chromosome types:
        
         X    X chromosome                    -> 23
         Y    Y chromosome                    -> 24
         XY   Pseudo-autosomal region of X    -> 25
         MT   Mitochondrial                   -> 26
        
         */
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                if (var.genotypeIndex < 0) {
                    continue;
                }
                //Important: ingnore the variants with more thant 2 alleles
                if (var.getAltAlleles().length > 1) {
                    continue;
                }
                bwMap.write(String.valueOf(chromIndex + 1));

                bwMap.write("\t");
                if (var.getLabel() == null) {
                    bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                } else {
                    String label = var.getLabel();
                    if (label.startsWith("rs")) {
                        bwMap.write(label + "\t");
                    } else {
                        bwMap.write("chr" + chromosomes[chromIndex].getName() + ":" + var.refStartPosition + "\t");
                    }
                }
                bwMap.write("0\t");
                bwMap.write(String.valueOf(var.refStartPosition));
                bwMap.write("\t");
                bwMap.write(String.valueOf(var.getRefAllele()));
                bwMap.write("\t");
                bwMap.write(var.getAltAlleles()[0]);
                bwMap.write("\n");
                varsNum++;
            }
        }
        bwMap.close();

        for (Individual indiv : subjectList) {
            if (indiv == null) {
                continue;
            }
            indivNum++;
            bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                    + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
            bwPed.write("\n");
        }
        bwPed.close();

        int bufSize = 1024;

        ByteBuffer byteBuffer = ByteBuffer.allocate(bufSize);

        //|-magic number-
        //01101100 00011011
        byte byteInfo = (byte) 0x6C;
        byteBuffer.put(byteInfo);
        byteInfo = (byte) 0x1B;
        byteBuffer.put(byteInfo);
        //|-mode-| 00000001 (SNP-major)
        //00000001 
        byteInfo = 1;

        byteBuffer.put(byteInfo);
        byteBuffer.flip();
        fileChannel.write(byteBuffer);
        byteBuffer.clear();

        //temperally store the genotype information 
        boolean[] bits = new boolean[5];
        int indivIndex = 8;
        int leftCapcitiy = bufSize;
        int end = 0;
        byte x;
        /*
         missing	Reference homozygous	Heterozygous 	Alternative homozygous
         VCF genotype	./.	0/0	0/1	1/1
         Bits	        00  	01	10	11
         Order	0	1	2	3        
         */

        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                if (var.genotypeIndex < 0) {
                    continue;
                }
//Important: ingnore the variants with more thant 2 alleles
                if (var.getAltAlleles().length > 1) {
                    continue;
                }


                /*
                 * 00  Homozygote "1"/"1"
                 01  Heterozygote
                 11  Homozygote "2"/"2"
                 10  Missing genotype
                 */
//renew the bytes for each variant, each byte for 4 subjects at most
                indivIndex = 4;
                for (Individual indiv : subjectList) {
                    if (indiv == null) {
                        continue;
                    }

                    if (isPhasedGty) {
                        /*
                         missing	Reference homozygous	Heterozygous 	Heterozygous 	Alternative homozygous
                         VCF genotype	.|.	0|0	0|1	1|0	1|1
                         Bits      	000  	001	010	011	100
                         Order	0	1	2	3	4        
                         */
                        indiv.markerGtySetArray[chromIndex].getPhasedGtyBitAt(var.genotypeIndex, bits, 2);
                        //due to over-flow problme we nee this
                        byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                        //Homozygote
                        if (!bits[0] && !bits[1] && bits[2]) {
                        } else if (bits[0] && !bits[1] && !bits[2]) {
                            //Homozygote                          
                            byteInfo = (byte) (byteInfo | 0XC0);
                        } else if ((bits[0] && !bits[1] && bits[2]) || (bits[0] && !bits[1] && !bits[2])) {
                            //Heterozygote
                            //annoyed!!! The plink binary annotation is different from plink excutable tool for the 01 10 definition
                            byteInfo = (byte) (byteInfo | 0X80);
                        } else if (!bits[0] && !bits[1] && !bits[2]) {
                            //missing   
                            byteInfo = (byte) (byteInfo | 0X40);
                        }
                    } else {
//to be modified                       
// indiv.markerGtySetArray[chromIndex].getUnphasedGtyBitAt(var.genotypeIndex, bits, 2);
                        //due to over-flow problme we nee this
                        byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                        //Homozygote
                        if (!bits[0] && bits[1]) {
                        } else if (bits[0] && bits[1]) {
                            //Homozygote                          
                            byteInfo = (byte) (byteInfo | 0XC0);
                        } else if (bits[0] && !bits[1]) {
                            //Heterozygote
                            //annoyed!!! The plink binary annotation is different from plink excutable tool for the 01 10 definition
                            byteInfo = (byte) (byteInfo | 0X80);
                        } else if (!bits[0] && !bits[1]) {
                            //missing   
                            byteInfo = (byte) (byteInfo | 0X40);
                        }
                    }
                    indivIndex--;
                    if (indivIndex == 0) {
                        byteBuffer.put(byteInfo);
                        leftCapcitiy--;
                        indivIndex = 4;
                        if (leftCapcitiy == 0) {
                            byteBuffer.flip();
                            fileChannel.write(byteBuffer);
                            byteBuffer.clear();
                            leftCapcitiy = bufSize;
                        }
                        // if (indID.equals("C")) 
                        //System.out.println(BitByteUtil.byteToBinaryString(byteInfo));
                    }
                }
//Subject to debug. do not know why it is not correct
                if (indivIndex != 4) {
                    //offset the missing so that the genotypes can start from the fist position 
                    //for (int i=0;i<indivIndex;i++) byteInfo = (byte) ((byteInfo >>> 2) & 0X3F);
                    byteInfo = (byte) (byteInfo >>> (indivIndex * 2));
                    // System.out.println(end + " : " + BitByteUtil.byteToBinaryString(byteInfo));
                    //end++; 
                    byteBuffer.put(byteInfo);
                    leftCapcitiy--;
                }
                if (leftCapcitiy != bufSize) {
                    byteBuffer.flip();
                    fileChannel.write(byteBuffer);
                    byteBuffer.clear();
                    leftCapcitiy = bufSize;
                }
            }
        }

        fileChannel.close();
        rafKed.close();
        String info = "Genotype of " + varsNum + " sequence variant(s) and " + indivNum + " individuals are saved \nin "
                + exportPath + ".fam " + exportPath + ".bim " + exportPath + ".bed " + " with Plink binary genotype format.";
        System.out.println(info);
    }

    public void export2ANNOVARInput(String exportPath) throws Exception {
        BufferedWriter bw = new BufferedWriter(new FileWriter(exportPath));
        int signNum = 0;
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                /*
                 * Chr	Start	End	Ref	Obs	Comments
                 1	84647761	84647761	C	T	comments: rs6576700 or SNP_A-1780419, a SNP in Affymetrix SNP arrays
                 1	13133880	13133881	TC	-	comments: rs59770105, a 2-bp deletion
                 1	11326183	11326183	-	AT	comments: rs35561142, a 2-bp insertion
                 1	105293754	105293754	A	ATAAA	comments: rs10552169, a block substitution
                 13	19695176	20003944	0	-	comments: a 342kb deletion encompassing GJB6, associated with hearing loss                
                 */

                for (String altAllele : var.getAltAlleles()) {
                    bw.write(chromosomes[chromIndex].getName());
                    bw.write(" ");

                    if (var.isIndel) {
                        signNum = 0;
                        if (altAllele.charAt(0) == '+') {
                            for (int t = 0; t < altAllele.length(); t++) {
                                if (altAllele.charAt(t) == '+') {
                                    signNum++;
                                } else {
                                    break;
                                }
                            }
                            signNum--;
                            bw.write(String.valueOf(var.refStartPosition + signNum));
                            bw.write(" ");
                            bw.write(String.valueOf(var.refStartPosition + signNum));
                            bw.write(" ");
                            bw.write("-");
                            bw.write(" ");
                            bw.write(altAllele.substring(signNum + 1));
                        } else if (altAllele.charAt(altAllele.length() - 1) == '+') {
                            bw.write(String.valueOf(var.refStartPosition));
                            bw.write(" ");
                            bw.write(String.valueOf(var.refStartPosition));
                            bw.write(" ");
                            bw.write("-");
                            bw.write(" ");
                            bw.write(altAllele.substring(1));
                        } else if (altAllele.charAt(altAllele.length() - 1) == '-') {
                            for (int t = 0; t < altAllele.length(); t++) {
                                if (altAllele.charAt(t) != '-') {
                                    signNum++;
                                } else {
                                    break;
                                }
                            }

                            bw.write(String.valueOf(var.refStartPosition + signNum));
                            bw.write(" ");
                            bw.write(String.valueOf(var.refStartPosition + altAllele.length() - 1));
                            bw.write(" ");
                            bw.write(var.getRefAllele().substring(signNum));
                            bw.write(" ");
                            bw.write("-");
                        } else if (altAllele.charAt(0) == '-') {
                            for (int t = 0; t < altAllele.length(); t++) {
                                if (altAllele.charAt(t) == '-') {
                                    signNum++;
                                } else {
                                    break;
                                }
                            }

                            bw.write(String.valueOf(var.refStartPosition + 1));
                            bw.write(" ");
                            bw.write(String.valueOf(var.refStartPosition + signNum));
                            bw.write(" ");
                            bw.write(var.getRefAllele().substring(0, signNum));
                            bw.write(" ");
                            bw.write("-");
                        }

                    } else {
                        bw.write(String.valueOf(var.refStartPosition));
                        bw.write(" ");
                        bw.write(String.valueOf(var.refStartPosition));
                        bw.write(" ");
                        bw.write(String.valueOf(var.getRefAllele()));
                        bw.write(" ");
                        bw.write(altAllele);
                    }

                    bw.write("\n");
                }
            }
        }
        bw.close();
    }

    public void export2EnsembleInput(String exportPath) throws Exception {
        BufferedWriter bw = new BufferedWriter(new FileWriter(exportPath));
        int i = 0;
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                /*
                
                 1  909238  909238  G/C  +
                 3  361464  361464  A/-  +
                 5  121187650  121188519  DUP
                
                 */

                for (String altAllele : var.getAltAlleles()) {
                    bw.write(chromosomes[chromIndex].getName());
                    bw.write(" ");
                    if (altAllele.charAt(0) == '+') {
                        bw.write(String.valueOf(var.refStartPosition));
                        bw.write(" ");
                        bw.write(String.valueOf(var.refStartPosition));
                        bw.write(" ");
                        bw.write("-");
                        bw.write(" ");
                        bw.write(altAllele.substring(1));
                        bw.write(" ");
                        bw.write("+");
                    } else if (altAllele.charAt(0) == '-') {
                        bw.write(String.valueOf(var.refStartPosition + 1));
                        bw.write(" ");
                        bw.write(String.valueOf(var.refStartPosition + altAllele.length() - 1));
                        bw.write(" ");
                        bw.write(altAllele.substring(1));
                        bw.write(" ");
                        bw.write("-");
                        bw.write(" ");
                        bw.write("+");
                    } else {
                        bw.write(String.valueOf(var.refStartPosition));
                        bw.write(" ");
                        bw.write(String.valueOf(var.refStartPosition));
                        bw.write(" ");
                        bw.write(String.valueOf(var.getRefAllele()));
                        bw.write("/");
                        bw.write(altAllele);
                        bw.write(" ");
                        bw.write("+");
                    }
                    bw.write("\n");
                }
            }
        }
        bw.close();
    }

    public void export2SeattleSeqInput(String exportPath) throws Exception {
        BufferedWriter bw = new BufferedWriter(new FileWriter(exportPath));
        for (int chromIndex = 0; chromIndex < STAND_CHROM_NAMES.length; chromIndex++) {
            if (chromosomes[chromIndex] == null) {
                continue;
            }
            for (Variant var : chromosomes[chromIndex].variantList) {
                //format: 4 white-space-separated columns in the input file, in the order chromosome (chr1 or chr2 or ... or chr22 or chrX or chrY), genomic coordinate (human NCBI 36, 1-based), reference base, Maq base (using ambiguity codes).
                bw.write("chr" + chromosomes[chromIndex].getName());
                bw.write(" ");
                bw.write(String.valueOf(var.refStartPosition));
                bw.write(" ");
                bw.write(String.valueOf(var.getRefAllele()));
                bw.write(" ");
                bw.write(String.valueOf(var.getAltAlleles()[0]));
                bw.write("\n");
            }
        }
        bw.close();
    }
}
