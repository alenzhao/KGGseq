/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package org.cobi.kggseq;

import cern.colt.list.DoubleArrayList;
import cern.colt.list.IntArrayList;
import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import java.awt.GraphicsEnvironment;
import java.awt.Toolkit;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.OutputStreamWriter;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.WritableByteChannel;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;
import javax.swing.JFrame;
import org.apache.log4j.Logger;
import static org.cobi.kggseq.Constants.VAR_FEATURE_NAMES;
import static org.cobi.kggseq.GlobalManager.RESOURCE_PATH;
import org.cobi.kggseq.controller.BinaryGtyProcessor;
import org.cobi.kggseq.controller.CandidateGeneExtender;
import org.cobi.kggseq.controller.GeneAnnotator;
import org.cobi.kggseq.controller.GeneRegionParser;
import org.cobi.kggseq.controller.LinkageFileParser;
import org.cobi.kggseq.controller.SimpleFormatParser;
import org.cobi.kggseq.controller.VCFParser;
import org.cobi.kggseq.controller.VariantAnnotator;
import org.cobi.kggseq.controller.VariantFilter;
import org.cobi.kggseq.dialog.PlotShowFrame;
import org.cobi.kggseq.entity.AnnotationSummarySet;
import org.cobi.kggseq.entity.CNVRegionParser;
import org.cobi.kggseq.entity.Chromosome;
import org.cobi.kggseq.entity.CombOrderComparator;
import org.cobi.kggseq.entity.CombOrders;
import org.cobi.kggseq.entity.FiltrationSummarySet;
import org.cobi.kggseq.entity.Genome;
import org.cobi.kggseq.entity.Individual;
import org.cobi.kggseq.entity.PPIGraph;
import org.cobi.kggseq.entity.Pathway;
import org.cobi.kggseq.entity.ReferenceGenome;
import org.cobi.kggseq.entity.RegressionParams;
import org.cobi.kggseq.entity.Variant;
import org.cobi.randomforests.MyRandomForest;
import org.cobi.randomforests.MyRandomTree;
import org.cobi.util.file.LocalFileFunc;
import org.cobi.util.net.NetUtils;
import org.cobi.util.plot.PValuePainter;
import org.cobi.util.stat.MultipleTestingMethod;
import org.cobi.util.text.LocalExcelFile;
import org.cobi.util.text.LocalFile;
import org.cobi.util.text.Util;
import org.objenesis.strategy.StdInstantiatorStrategy;
import org.rosuda.REngine.Rserve.RConnection;
import org.rosuda.REngine.Rserve.RserveException;

/**
 *
 * @author mxli
 */
public class CUIApp implements Constants {

    Options options;
    private static final Logger LOG = Logger.getLogger(CUIApp.class);

    public CUIApp(Options options) throws Exception {
        this.options = options;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        String headInfor = "@----------------------------------------------------------@\n" + "|        " + PREL + "        |     v" + PVERSION + "     |   " + PDATE + "     |\n"
                + "|----------------------------------------------------------|\n" + "|  (C) 2011 Miaoxin Li,  limx54@yahoo.com                  |\n"
                + "|----------------------------------------------------------|\n" + "|  For documentation, citation & bug-report instructions:  |\n"
                + "|        http://statgenpro.psychiatry.hku.hk/kggseq        |\n" + "@----------------------------------------------------------@";

        long time = System.nanoTime();
        Options option = new Options();
        try {
            if (args.length == 1 && !args[0].startsWith("--")) {
                option.readOptions(args[0]);
            } else if (args.length >= 1) {
                option.readOptions(args);
            } else {
                System.out.println("Usage: java -Xmx1g -jar kggseq.jar param.txt\n Or:  java -Xmx1g -jar kggseq.jar [options] ...");
                return;
            }
            String param = option.parseOptions();
            // System.out.println(headInfor);
            LOG.info("\n" + headInfor + "\nEffective settings :\n" + param);

            GlobalManager.initiateVariables(option.refGenomeVersion, option.resourceFolder, option.maxGtyAlleleNum);
            if (option.needRconnection) {
                RConnection rcon = null;
                try {
                    rcon = new RConnection();
                } catch (RserveException ex) {
                    if (ex.getMessage().contains("Cannot connect")) {
                        // System.out.println(ex.getMessage() + "\t" +
                        // ex.getRequestReturnCode() + "\t" +
                        // ex.getRequestErrorDescription());
                        String infor = "Please open your R and type the following commands to allow kggseq to use it:\npack=\"Rserve\";\n"
                                + "if (!require(pack,character.only = TRUE))   { install.packages(pack,dep=TRUE,repos=\'http://cran.us.r-project.org\');   if(!require(pack,character.only = TRUE)) stop(\"Package not found\")   }\n"
                                + "library(\"Rserve\");\nRserve(debug = FALSE, port = 6311, args = NULL)\n";
                        LOG.fatal(infor);
                        TimeUnit.SECONDS.sleep(1);
                    }
                    System.exit(1);
                } finally {
                    if (rcon != null) {
                        rcon.close();
                    }
                }
            }
            if (!option.noLibCheck || !option.noResCheck) {
                GlobalManager.checkConnection();
            }
            if (!option.noLibCheck) {
                if (GlobalManager.isConnectInternet) {
                    if (NetUtils.checkLibFileVersion()) {
                        return;
                    }
                }
            }

            if (!option.noResCheck) {
                if (GlobalManager.isConnectInternet) {
                    NetUtils.checkLatestResource(option);
                }
            } else {
                if (GlobalManager.isConnectInternet) {
                    // must check avaible resources
                    NetUtils.checkResourceList(option);
                }
            }

            CUIApp main = new CUIApp(option);
            main.process();
            time = System.nanoTime() - time;
            time = time / 1000000000;
            long min = time / 60;
            long sec = time % 60;
            LOG.info("Elapsed time: " + min + " min. " + sec + " sec.");
            if (option.needLog) {
                String info = "The log information is save in " + option.outputFileName + ".log";
                System.out.println(info);
            }

            Toolkit.getDefaultToolkit().beep();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public void showPlots(final File[] plotFiles) {
        if (!GraphicsEnvironment.isHeadless()) {
            java.awt.EventQueue.invokeLater(new Runnable() {

                @Override
                public void run() {
                    PlotShowFrame psf = new PlotShowFrame();
                    psf.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                    for (final File file : plotFiles) {
                        if (file == null) {
                            continue;
                        }
                        psf.insertImage2PlottingPane(file);
                    }
                    psf.setVisible(true);
                }
            });
        } else {
            String info = "But no avaible graphics environment to present the figure(s) here!";
            LOG.info(info);
        }
    }

    public void process() throws Exception {
        Genome uniqueGenome = null;
        Set<String> caseSet = null;
        Set<String> controlSet = null;
        Set<String> unkownSet = null;
        List<Individual> subjectList = new ArrayList<Individual>();

        boolean needGty = false;
        File finalFilteredInFile = null;
        IntArrayList allEffectIndivIDs = new IntArrayList();
        VCFParser vsParser = new VCFParser();
        try {
            if (options.localFilterVCFFileNames != null) {
                for (String localFilterFileName : options.localFilterVCFFileNames) {
                    File localFileFiler = new File(localFilterFileName + ".kggseq.filter.txt");
                    LOG.info("Prepare annotation resources from local VCF file(s)...");
                    // gtyCorrdiates used to keep the sequential order
                    uniqueGenome = vsParser.readVariantGtyFilterOnly(localFilterFileName, options.threadNum, null, options.inputFileName, options.seqQual, options.minMappingQuality, options.maxStandBias,
                            options.maxFisherStandBias, options.maxGtyAlleleNum, options.gtyQual, options.minGtySeqDP, options.maxAltAlleleFracRefHom, options.minAltAlleleFractHet,
                            options.minAltAlleleFractAltHom, options.vcfFilterLabelsIn, options.minOBS, options.sampleMafOver, options.sampleMafLess, options.considerSNV, options.considerIndel,
                            options.gtySecPL, options.gtyBestGP, options.needProgressionIndicator, false, false, false, false, null, null);

                    BufferedWriter annovarFilteredInFileWriter = null;
                    if(options.outGZ){
                        GZIPOutputStream gzOut=new GZIPOutputStream(new FileOutputStream(localFileFiler.getCanonicalPath()+".gz"));
                        annovarFilteredInFileWriter = new BufferedWriter(new OutputStreamWriter(gzOut));
                    }else{
                        annovarFilteredInFileWriter = new BufferedWriter(new FileWriter(localFileFiler));
                    }                   
                    Chromosome[] chromosomes = uniqueGenome.getChromosomes();

                    for (int chromID = 0; chromID < chromosomes.length; chromID++) {
                        uniqueGenome.loadVariantFromDisk(chromID);
                        List<Variant> chromosomeVar = chromosomes[chromID].variantList;
                        if (chromosomeVar == null || chromosomeVar.isEmpty()) {
                            continue;
                        }
                        uniqueGenome.export2ANNOVARInput(annovarFilteredInFileWriter, chromID);
                        chromosomes[chromID].variantList.clear();
                    }
                    annovarFilteredInFileWriter.close();
                    uniqueGenome.removeTempFileFromDisk();
                    String infor = "The VCF filtration data " + localFilterFileName + " have been converted into a standard filtration dataset of kggseq, "
                            + localFileFiler.getCanonicalPath() + ".\nYou can directly use the standard one next time by \'--local-filter " + localFileFiler.getCanonicalPath()
                            + " \', which is faster!\n";
                    LOG.info(infor);
                    //  varFilter.markByANNOVARefFormat(uniqueGenome, localFileFiler.getCanonicalPath(), localFileFiler.getName(), options.needProgressionIndicator);
                }
            }

            if (options.inputFormat.endsWith("--vcf-file")) {
                // if pedigree file is specified options.indivPhenos will be
                // ignored
                if (options.pedFile != null) {
                    LinkageFileParser linkPedParser = new LinkageFileParser();

                    linkPedParser.readPedigreeOnly(options.pedFile, subjectList, options.useCompositeSubjectID);
                    caseSet = new HashSet<String>();
                    controlSet = new HashSet<String>();
                    unkownSet = new HashSet<String>();

                    for (Individual indiv : subjectList) {
                        if (indiv.getAffectedStatus() == 1) {
                            controlSet.add(indiv.getLabelInChip());
                        } else if (indiv.getAffectedStatus() == 2) {
                            caseSet.add(indiv.getLabelInChip());
                        } else {
                            unkownSet.add(indiv.getLabelInChip());
                        }
                    }

                } /*
                 * else if
                 * (options.genetModel.equals("--compound-heterozygosity")
                 * && options.pedFile == null) { throw new Exception(
                 * "Please sepcify the relationship of subjects  by \'--ped-file path/to/pedigree/file\' for compound heterozygosity model checking!"
                 * ); }
                 */ else if (options.indivPhenos != null) {
                    caseSet = new HashSet<String>();
                    controlSet = new HashSet<String>();
                    unkownSet = new HashSet<String>();
                    for (String indivID : options.indivPhenos) {
                        String label = indivID.substring(0, indivID.indexOf(':'));
                        String d = indivID.substring(indivID.indexOf(":") + 1);
                        Individual indiv = new Individual();
                        if (d.charAt(0) == '1') {
                            controlSet.add(label);
                        } else if (d.charAt(0) == '2') {
                            caseSet.add(label);
                        } else {
                            unkownSet.add(label);
                        }
                        indiv.setLabelInChip(label);
                        indiv.setFamilyID(label);
                        indiv.setIndividualID(label);
                        indiv.setDadID("0");
                        indiv.setMomID("0");
                        indiv.setAffectedStatus(d.charAt(0) - '0');
                        subjectList.add(indiv);
                    }
                }

                if (options.pedFile != null || options.indivPhenos != null) {
                    if (caseSet.isEmpty() && controlSet.isEmpty()) {
                        String infor = ("All subjects in phenotype or pedigree file have unknown disease status.\n"
                                + "    Please specify the clear disease status for AT LEAST one subject!!");
                        throw new Exception(infor);
                    }
                }

                if (options.mergeGtyDb != null && options.isPlinkPedOut || options.isPlinkBedOut || options.isBinaryGtyOut) {
                    needGty = true;
                } else if (options.sampleGtyHardFilterCode != null) {
                    for (int i = 0; i < 9; i++) {
                        if (options.sampleGtyHardFilterCode.contains(String.valueOf(i))) {
                            needGty = true;
                            break;
                        }
                    }
                } else if (options.ibsCheckCase >= 0 || options.homozygousRegionCase >= 0) {
                    needGty = true;
                } else if (options.doubleHitGenePhasedFilter || options.doubleHitGeneTriosFilter) {
                    needGty = true;
                }

                boolean needReadsInfor = false;
                // options.sampleVarHardFilterCode
                if (options.sampleGtyHardFilterCode != null && (options.sampleGtyHardFilterCode.contains("7") || options.sampleGtyHardFilterCode.contains("8"))) {
                    needReadsInfor = true;
                }

                // gtyCorrdiates used to keep the sequential order
                uniqueGenome = vsParser.readVariantGtyFilterOnly(options.outputFileName, options.threadNum, null, options.inputFileName, options.seqQual, options.minMappingQuality, options.maxStandBias,
                        options.maxFisherStandBias, options.maxGtyAlleleNum, options.gtyQual, options.minGtySeqDP, options.maxAltAlleleFracRefHom, options.minAltAlleleFractHet,
                        options.minAltAlleleFractAltHom, options.vcfFilterLabelsIn, options.minOBS, options.sampleMafOver, options.sampleMafLess, options.considerSNV, options.considerIndel,
                        options.gtySecPL, options.gtyBestGP, options.needProgressionIndicator, needGty, needReadsInfor, options.needGtyQual, false, subjectList, allEffectIndivIDs);

                /*
                 * if (!subjectMap.isEmpty()) { FileOutputStream objFOut =
                 * new FileOutputStream(outName + ".gty.obj");
                 * BufferedOutputStream objOBfs = new
                 * BufferedOutputStream(objFOut); ObjectOutputStream
                 * localObjOut = new ObjectOutputStream(objOBfs);
                 * 
                 * localObjOut.writeObject(subjectMap); localObjOut.flush();
                 * localObjOut.close(); objOBfs.flush(); objOBfs.close();
                 * objFOut.close(); }
                 */
            } else if (options.inputFormat.endsWith("--tmp-file")) {
                SimpleFormatParser pileParser = new SimpleFormatParser();
                uniqueGenome = pileParser.readCancerGenomeVariantFormat(options.outputFileName, options.inputFileName, options.needProgressionIndicator);
            } else if (options.inputFormat.endsWith("--no-gty-vcf-file")) {
                // gtyCorrdiates used to keep the sequential order
                uniqueGenome = vsParser.readVariantGtyFilterOnly(options.outputFileName, options.threadNum, null, options.inputFileName, options.seqQual, options.minMappingQuality, options.maxStandBias,
                        options.maxFisherStandBias, options.maxGtyAlleleNum, options.gtyQual, options.minGtySeqDP, options.maxAltAlleleFracRefHom, options.minAltAlleleFractHet,
                        options.minAltAlleleFractAltHom, options.vcfFilterLabelsIn, options.minOBS, options.sampleMafOver, options.sampleMafLess, options.considerSNV, options.considerIndel,
                        options.gtySecPL, options.gtyBestGP, options.needProgressionIndicator, needGty, false, options.needGtyQual, true, subjectList, allEffectIndivIDs);
            } else if (options.inputFormat.endsWith("--ked-file")) {
                BinaryGtyProcessor bgp = new BinaryGtyProcessor(options.inputFileName);
                bgp.readPedigreeFile(subjectList);
                int[] counts = new int[3];
                Arrays.fill(counts, 0);
                uniqueGenome = bgp.readVariantsMapFile(counts);

                caseSet = new HashSet<String>();
                controlSet = new HashSet<String>();
                unkownSet = new HashSet<String>();

                for (Individual indiv : subjectList) {
                    if (indiv.getAffectedStatus() == 1) {
                        controlSet.add(indiv.getLabelInChip());
                    } else if (indiv.getAffectedStatus() == 2) {
                        caseSet.add(indiv.getLabelInChip());
                    }
                }
                bgp.readBinaryGenotype(subjectList, uniqueGenome);

                // subject to do something more
                String info = counts[0] + " variant-lines (" + counts[2] + " indels) are scanned; and " + counts[1] + " variants of " + subjectList.size() + " individual(s) are valid in " + options.inputFileName + ".";
                LOG.info(info);
                uniqueGenome.writeChromsomeToDiskClean();
            }

            //-----------------------Annotate variants on each chromsome-------------------------------
            VariantAnnotator varAnnoter = new VariantAnnotator();
            VariantFilter varFilter = new VariantFilter();
            FiltrationSummarySet minMissingQCFilter1 = new FiltrationSummarySet("missingQC", uniqueGenome.getVariantFeatureNum());
            minMissingQCFilter1.initiateAMessage(0, "variants are ignored due to the number of heterozygous genotypes <" + options.minHetA
                    + " or that of alternative homozygous genotypes <" + options.minHomA + " in cases.");

            minMissingQCFilter1.initiateAMessage(0, "variants are ignored due to the number of heterozygous genotypes <" + options.minHetU
                    + " or that of alternative homozygous genotypes <" + options.minHomU + " in controls.");
            minMissingQCFilter1.initiateAMessage(0, "variants are ignored due to the number of non-null genotypes in cases <" + options.minOBSA + ".");
            minMissingQCFilter1.initiateAMessage(0, "variants are ignored due to the number of non-null genotypes in controls <" + options.minOBSU + ".");
            minMissingQCFilter1.initiateAMessage(0, "variant(s) are left after filtration according to minimal successful genotype calling rates in patients and healthy individuals.");

            String hardFilterModel = options.sampleGtyHardFilterCode;
            int filterNum = 6;
            boolean[] uniqueFilters = new boolean[2];
            boolean[] genotypeFilters = new boolean[filterNum];
            Arrays.fill(uniqueFilters, false);
            Arrays.fill(genotypeFilters, false);
            boolean filterByModel = false;
            FiltrationSummarySet inheritanceModelFilter2 = null;
            FiltrationSummarySet denovoModelFilter3 = null;
            FiltrationSummarySet doubleHitGeneModelFilter19 = null;
            FiltrationSummarySet somaticModelFilter4 = null;
            List<int[]> setSampleIDList = null;
            List<String> setSampleLabelList = new ArrayList<String>();
            String currentLine;

            if (options.sampleGtyHardFilterCode != null && options.sampleGtyHardFilterCode.length() > 0) {
                for (int i = 0; i < filterNum; i++) {
                    String[] cells = options.sampleGtyHardFilterCode.split(",");
                    for (int t = 0; t < cells.length; t++) {
                        int s = Integer.parseInt(cells[t]) - 1;
                        if (s < filterNum) {
                            genotypeFilters[s] = true;
                            filterByModel = true;
                        }
                    }
                }
            }

            if (filterByModel) {
                inheritanceModelFilter2 = new FiltrationSummarySet("InheritanceModel", uniqueGenome.getVariantFeatureNum());
                inheritanceModelFilter2.initiateAMessage(0, "variants are ignored by genotype-based hard-filtering.");
                inheritanceModelFilter2.initiateAMessage(0, "variant(s) are left after filtration according to inheritance mode at genotypes, " + hardFilterModel + "!");
            }

            if (options.sampleGtyHardFilterCode != null && (options.sampleGtyHardFilterCode.contains("7"))) {
                denovoModelFilter3 = new FiltrationSummarySet("DenovoModel", uniqueGenome.getVariantFeatureNum());
                setSampleIDList = new ArrayList<int[]>();
                varFilter.matchTrioSet(subjectList, setSampleIDList);
                if (subjectList.isEmpty()) {
                    String infor = "No recognizable trios! To detect de novo mutation, you have to set the parents-child relationsby the tag --ped-file path/to/file!";
                    throw new Exception(infor);
                }
                uniqueGenome.addVariantFeatureLabel("DenovoMutationEvent");
                denovoModelFilter3.initiateAMessage(0, "variant(s) are left after filtration by denovo mutation!");
            }

            if (options.causingPredType == 2) {
                somaticModelFilter4 = new FiltrationSummarySet("SomaticModel", uniqueGenome.getVariantFeatureNum());
            }

            if (options.sampleGtyHardFilterCode != null && (options.sampleGtyHardFilterCode.contains("8"))) {
                // search somatic mutation between cancer tissue and non-cancer tissues
                if (options.indivPairs == null) {
                    String infor = "To detect somatic mutation, you have to set the tumor sample and non-tumor samples pairs by the tag --indiv-pair tumorIndivID1:normalIndivID1,tumorIndivID2:normalIndivID2";
                    throw new Exception(infor);
                }

                // search somatic mutation between cancer tissue and non-cancer tissues
                // match pairs                
                setSampleIDList = new ArrayList<int[]>();
                varFilter.matchTumorNontumorPair(options.indivPairs, subjectList, setSampleIDList, setSampleLabelList);
                if (setSampleIDList.isEmpty()) {
                    List<String> vcfInds = new ArrayList<String>();
                    List<String> pedIndivs = new ArrayList<String>();
                    for (String pair : options.indivPairs) {
                        String[] invdivs = pair.split(":");
                        vcfInds.add(invdivs[0]);
                        vcfInds.add(invdivs[1]);
                    }

                    for (int t = 0; t < subjectList.size(); t++) {
                        pedIndivs.add(subjectList.get(t).getLabelInChip());
                    }

                    String infor = "No recognizable matched Tumor<->Nontumor pairs!\n"
                            + ("The subject IDs in the specified VCF file(s), " + vcfInds.toString() + " are not indentical to those in the phenotype or pedigree file " + pedIndivs.toString() + "!!");
                    throw new Exception(infor);
                }
                somaticModelFilter4.initiateAMessage(0, "variant(s) are left after filtration by somatic mutations!");
                uniqueGenome.addVariantFeatureLabel("SomaticMutationEvent");
                uniqueGenome.addVariantFeatureLabel("TNTRefAltRead,P,OR");
            }

            AnnotationSummarySet assSVHF = null;
            double[] thrholds = new double[4];
            if (options.sampleVarHardFilterCode != null && options.sampleVarHardFilterCode.equals("association") && options.inputFormat.endsWith("--vcf-file")) {
                List<String> nameList = new ArrayList<String>();
                nameList.add("Allelic");
                nameList.add("Dominant");
                nameList.add("Recessive");
                nameList.add("Genotypic");
                List<DoubleArrayList> pvalueList = varAnnoter.assocTestVar(uniqueGenome);
                PValuePainter pvPainter = new PValuePainter(800, 600);
                File plotFile2 = new File(options.outputFileName + ".all.qq.png");
                StringBuilder message = new StringBuilder();

                message.append("\nSignificance level of p value cutoffs for the overal error rate ").append(options.pValueThreshold).append(" :\n");
                for (int i = 0; i < 4; i++) {
                    if (options.multipleTestingMethod == null || options.multipleTestingMethod.equals("no")) {
                        thrholds[i] = options.pValueThreshold;
                    } else if (options.multipleTestingMethod.equals("benfdr")) {
                        thrholds[i] = MultipleTestingMethod.benjaminiHochbergFDR(options.pValueThreshold, pvalueList.get(i));
                    } else if (options.multipleTestingMethod.equals("bonhol")) {
                        thrholds[i] = MultipleTestingMethod.bonferroniHolmFWE(options.pValueThreshold, pvalueList.get(i));
                    } else if (options.multipleTestingMethod.equals("bonf")) {
                        thrholds[i] = options.pValueThreshold / pvalueList.get(i).size();
                    }
                    message.append(nameList.get(i));
                    message.append(": ");
                    message.append(thrholds[i]).append("\n");
                }

                LOG.info(message);
                pvPainter.drawMultipleQQPlot(pvalueList, nameList, null, plotFile2.getCanonicalPath(), 1E-10);
                String info = "The QQ plot saved in " + plotFile2.getCanonicalPath();
                LOG.info(info);
                showPlots(new File[]{plotFile2});

                assSVHF = new AnnotationSummarySet("test filter", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
            }

            AnnotationSummarySet[] varaintDBHardFilterFiles5 = null;
            AnnotationSummarySet[] varaintDBFilterFiles6 = null;

            int dbFileSize = options.varaintDBLableHardList != null ? options.varaintDBLableHardList.size() : 0;
            if (dbFileSize > 0) {
                varaintDBHardFilterFiles5 = new AnnotationSummarySet[dbFileSize];
                for (int i = 0; i < dbFileSize; i++) {
                    String dbLabelName = options.varaintDBLableHardList.get(i);
                    varaintDBHardFilterFiles5[i] = new AnnotationSummarySet(dbLabelName, LocalFileFunc.getBufferedReader(GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get(dbLabelName)), new StringBuilder(), 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                }
            }
            dbFileSize = options.varaintDBLableList != null ? options.varaintDBLableList.size() : 0;
            if (dbFileSize > 0) {
                varaintDBFilterFiles6 = new AnnotationSummarySet[dbFileSize];
                for (int i = 0; i < dbFileSize; i++) {
                    String dbLabelName = options.varaintDBLableList.get(i);
                    varaintDBFilterFiles6[i] = new AnnotationSummarySet(dbLabelName, LocalFileFunc.getBufferedReader(GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get(dbLabelName)), new StringBuilder(), 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                    uniqueGenome.addVariantFeatureLabel("altFreq@" + dbLabelName);
                }
            }

            FiltrationSummarySet geneDBFilter7 = null;
            int[] variantsCounters = null;
            dbFileSize = options.geneDBLabels != null ? options.geneDBLabels.length : 0;
            ReferenceGenome[] referenceGenomes = null;
            int[] availableFeatureSizeForGeneDB = new int[dbFileSize];
            if (dbFileSize > 0) {
                geneDBFilter7 = new FiltrationSummarySet("Gene DB", uniqueGenome.getVariantFeatureNum());

                geneDBFilter7.initiateAMessage(0, " variant(s) are left after filtering by gene features.");
                variantsCounters = new int[VAR_FEATURE_NAMES.length];
                Arrays.fill(variantsCounters, 0);
                referenceGenomes = new ReferenceGenome[dbFileSize];
                File domainFile = new File(GlobalManager.RESOURCE_PATH + "/UniprotDomain.txt.gz");
                GeneRegionParser grp = new GeneRegionParser();
                for (int i = 0; i < dbFileSize; i++) {
                    String geneDBLabel = options.geneDBLabels[i];
                    String dbFileName = options.PUBDB_FILE_MAP.get(geneDBLabel);

                    File idMapFile = null;
                    if (geneDBLabel.equals("gencode")) {
                        idMapFile = new File(GlobalManager.RESOURCE_PATH + "/UniprotEnsemblMap.tab.gz");
                        referenceGenomes[i] = grp.readRefGeneSeq(GlobalManager.RESOURCE_PATH + "/" + dbFileName, geneDBLabel, options.splicingDis, options.neargeneDis, domainFile, idMapFile);
                        uniqueGenome.setGencodeAnnot(true);
                        availableFeatureSizeForGeneDB[i] = uniqueGenome.getVariantFeatureNum();
                        uniqueGenome.addVariantFeatureLabel("UniProtFeatureForGEncode");
                    } else if (geneDBLabel.equals("refgene")) {
                        uniqueGenome.setRefSeqAnnot(true);
                        availableFeatureSizeForGeneDB[i] = uniqueGenome.getVariantFeatureNum();
                        uniqueGenome.addVariantFeatureLabel("UniProtFeatureForRefGene");
                        idMapFile = new File(GlobalManager.RESOURCE_PATH + "/UniprotRefSeqMap.tab.gz");
                        // unforturately the ucsc file rna fasta file
                        // are not always consistant with the ucsc
                        // chromsome fasta
                        // refGenome =
                        // grp.readRefGeneSeqUcsc(GlobalManager.RESOURCE_PATH
                        // + "/" + dbFileName,
                        // GlobalManager.RESOURCE_PATH + "/" +
                        // "refMrna.fa.gz", geneDBLabel,
                        // options.splicingDis, options.neargeneDis,
                        // domainFile, idMapFile);
                        referenceGenomes[i] = grp.readRefGeneSeq(GlobalManager.RESOURCE_PATH + "/" + dbFileName, geneDBLabel, options.splicingDis, options.neargeneDis, domainFile, idMapFile);
                    } else if (geneDBLabel.equals("ensembl")) {
                        idMapFile = new File(GlobalManager.RESOURCE_PATH + "/UniprotEnsemblMap.tab.gz");
                        referenceGenomes[i] = grp.readRefGeneSeq(GlobalManager.RESOURCE_PATH + "/" + dbFileName, geneDBLabel, options.splicingDis, options.neargeneDis, domainFile, idMapFile);
                        uniqueGenome.setEnsemblAnnot(true);
                        availableFeatureSizeForGeneDB[i] = uniqueGenome.getVariantFeatureNum();
                        uniqueGenome.addVariantFeatureLabel("UniProtFeatureForEnsembl");
                    } else if (geneDBLabel.equals("knowngene")) {
                        idMapFile = new File(GlobalManager.RESOURCE_PATH + "/UniprotUCSCKnownGeneMap.tab.gz");
                        referenceGenomes[i] = grp.readRefGeneSeq(GlobalManager.RESOURCE_PATH + "/" + dbFileName, geneDBLabel, options.splicingDis, options.neargeneDis, domainFile, idMapFile);
                        uniqueGenome.setKnownAnnot(true);
                        availableFeatureSizeForGeneDB[i] = uniqueGenome.getVariantFeatureNum();
                        uniqueGenome.addVariantFeatureLabel("UniProtFeatureForKnownGene");
                    }
                    referenceGenomes[i].setName(geneDBLabel);
                }
            }

            FiltrationSummarySet dbNSFPAnnot8 = null;
            FiltrationSummarySet dbNSFPPred9 = null;
            List<CombOrders> combOrderList = new ArrayList<CombOrders>();
            CombOrders fixedComb = null;
            MyRandomForest myRandomForest = null;
            int somatNumIndex = -1;
            int readInfoIndex = -1;
            // dbNSFP3.0
            int[] dbNSFP3ScoreIndexes = new int[]{5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18};
            int[] dbNSFP3PredicIndex = new int[]{19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31};
            if (!options.scoreDBLableList.isEmpty()) {
                for (String dbLabelName : options.scoreDBLableList) {
                    if (dbLabelName.equals("dbnsfp")) {
                        String dbFileName = options.PUBDB_FILE_MAP.get(dbLabelName);
                        String path = GlobalManager.RESOURCE_PATH + "/" + dbFileName + "Y.gz";
                        BufferedReader br = LocalFileFunc.getBufferedReader(path);
                        currentLine = br.readLine();
                        String[] cells = currentLine.split("\t");
                        br.close();

                        dbNSFPAnnot8 = new FiltrationSummarySet("dbNSFP", uniqueGenome.getVariantFeatureNum());
                        dbNSFPAnnot8.initiateAMessage(0, "coding nonsynonymous variants are assigned functional prediction scores.");

                        for (int t = 0; t < dbNSFP3ScoreIndexes.length; t++) {
                            uniqueGenome.getScoreLabels().add(cells[dbNSFP3ScoreIndexes[t]]);
                        }
                        for (int t = 0; t < dbNSFP3PredicIndex.length; t++) {
                            uniqueGenome.addVariantFeatureLabel(cells[dbNSFP3PredicIndex[t]]);
                        }
                        if (options.causingPredType == 0) {
                            // MendelFilter
                            String logitParamFile = GlobalManager.RESOURCE_PATH + "/mendelcausalrare" + options.dbsnfpVersion + ".param.gz";
                            br = LocalFileFunc.getBufferedReader(logitParamFile);
                            String line = null;

                            CombOrderComparator coc = new CombOrderComparator();
                            // String[] names = {"SLR_test_statistic", "SIFT_score",
                            // "Polyphen2_HDIV_score", "Polyphen2_HVAR_score", "LRT_score",
                            // "MutationTaster_score", "MutationAssessor_score", "FATHMM_score",
                            // "GERP++_NR", "GERP++_RS", "phyloP", "29way_logOdds"};
                            boolean isFixed = false;
                            if (!options.predictExplanatoryVar.startsWith("all") && !options.predictExplanatoryVar.startsWith("best")) {
                                isFixed = true;
                            }
                            float aucCutoff = 0.85f;
                            while ((line = br.readLine()) != null) {
                                if (line.trim().length() == 0) {
                                    continue;
                                }
                                cells = line.split("\t");
                                RegressionParams rp = new RegressionParams();

                                String[] values = cells[1].split(";");
                                rp.coef = new double[values.length];
                                for (int i = 0; i < rp.coef.length; i++) {
                                    rp.coef[i] = Double.parseDouble(values[i]);
                                }
                                rp.sampleCase2CtrRatio = Double.parseDouble(cells[2]);
                                rp.optimalCutoff = Double.parseDouble(cells[3].split(";")[0]);
                                rp.truePositiveRate = Double.parseDouble(cells[3].split(";")[1]);
                                rp.trueNegativeRate = Double.parseDouble(cells[3].split(";")[2]);

                                CombOrders co = new CombOrders(cells[0], Double.parseDouble(cells[4]), rp);
                                if (isFixed) {
                                    if (cells[0].equals(options.predictExplanatoryVar)) {
                                        fixedComb = co;
                                        break;
                                    }
                                } else {
                                    if (co.auc < aucCutoff) {
                                        continue;
                                    }
                                    combOrderList.add(co);
                                }

                            }

                            br.close();
                            Collections.sort(combOrderList, coc);
                            dbNSFPPred9 = new FiltrationSummarySet("dbNSFPMendelPred", uniqueGenome.getVariantFeatureNum());
                            uniqueGenome.addVariantFeatureLabel("DiseaseCausalProb_ExoVarTrainedModel");
                            uniqueGenome.addVariantFeatureLabel("IsRareDiseaseCausal_ExoVarTrainedModel");
                            uniqueGenome.addVariantFeatureLabel("BestCombinedTools:OptimalCutoff:TP:TN");

                            dbNSFPPred9.initiateAMessage(0, "variants (in");
                            dbNSFPPred9.initiateAMessage(0, "genes) are predicted to be disease-causal;");
                            dbNSFPPred9.initiateAMessage(0, "variants are predicted to be non-disease-causal according to the Logistic regression prediction model trained by ExoVar dataset (http://statgenpro.psychiatry.hku.hk/limx/kggseq/download/ExoVar.xls)");
                            dbNSFPPred9.initiateAMessage(0, "variant(s) are left after filtered by the disease mutation prediction.");
                        } else if (options.causingPredType == 2) {
                            File fileName = new File(GlobalManager.RESOURCE_PATH + "/CancerRandomForests" + options.dbsnfpVersion + ".obj");
                            if (!fileName.exists()) {
                                throw new Exception("Cannot find data in hard disk!");
                            }
                            Kryo kryo = new Kryo();

                            kryo.setReferences(false);
                            kryo.setRegistrationRequired(false);
                            kryo.setInstantiatorStrategy(new StdInstantiatorStrategy());
                            //note: it seems the order of registered classes is very very important 
                            kryo.register(MyRandomTree[].class);
                            kryo.register(MyRandomTree.class);
                            kryo.register(MyRandomForest.class);

                            Input input = new Input(new FileInputStream(fileName), 1024 * 1024);

                            myRandomForest = (MyRandomForest) kryo.readObject(input, MyRandomForest.class);
                            input.close();

                            /*
                             FileInputStream objFIn = new FileInputStream(fileName);
                             BufferedInputStream objIBfs = new BufferedInputStream(objFIn);
                             ObjectInputStream localObjIn = new ObjectInputStream(objIBfs);
                             MyRandomForest myRandomForest = (MyRandomForest) localObjIn.readObject();
                             localObjIn.close();
                             objIBfs.close();
                             objFIn.close();
                             */
                            dbNSFPPred9 = new FiltrationSummarySet("dbNSFPCancerPred", uniqueGenome.getVariantFeatureNum());
                            dbNSFPPred9.initiateAMessage(0, "variants (in");
                            dbNSFPPred9.initiateAMessage(0, "genes) are predicted to be cancer-driver;");
                            dbNSFPPred9.initiateAMessage(0, "variants are predicted to be non-cancer-driver according to a Random Forests prediction model trained by COSMIC dataset (http://cancer.sanger.ac.uk/cancergenome/projects/cosmic/).");
                            dbNSFPPred9.initiateAMessage(0, "variant(s) are left after filtered by the cancer-driver mutation prediction.");

                            uniqueGenome.addVariantFeatureLabel("IsCancerDriver_COSMICTrainedModel");
                            uniqueGenome.addVariantFeatureLabel("RandomForestScore");

                            List<String> featureLabels = uniqueGenome.getVariantFeatureLabels();
                            for (int i = 0; i < featureLabels.size(); i++) {
                                if (featureLabels.get(i).equals("SomaticMutationEvent")) {
                                    somatNumIndex = i;
                                } else if (featureLabels.get(i).equals("TNTRefAltRead,P,OR")) {
                                    readInfoIndex = i;
                                }
                                if (somatNumIndex >= 0 && readInfoIndex >= 0) {
                                    break;
                                }
                            }
                            // special consideration for pileup files
                            if (somatNumIndex < 0) {
                                for (int i = 0; i < featureLabels.size(); i++) {
                                    if (featureLabels.get(i).equals("Comments")) {
                                        somatNumIndex = i;
                                        break;
                                    }
                                }
                            }
                            uniqueGenome.addGeneFeatureLabel("#NonsynonymousVar");
                            uniqueGenome.addGeneFeatureLabel("#SynonymousVar");
                            uniqueGenome.addGeneFeatureLabel("NonsynonymousReadsRatio");
                            uniqueGenome.addGeneFeatureLabel("SynonymousReadsRatio");
                            if (readInfoIndex > 0) {
                                uniqueGenome.addGeneFeatureLabel("ReadsInfor");
                            }
                        }
                    }
                }
            }

            AnnotationSummarySet assGVF10 = null;
            if (options.geneVarFilter > 0) {
                assGVF10 = new AnnotationSummarySet("", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
            }

            AnnotationSummarySet assG11 = null;
            AnnotationSummarySet assV12 = null;
            AnnotationSummarySet assPPIG13 = null;
            AnnotationSummarySet assPPIV14 = null;
            AnnotationSummarySet assPWG15 = null;
            AnnotationSummarySet assPWV16 = null;
            PPIGraph ppiTree = null;
            Map<String, Pathway> mappedPathes = null;
            if (options.candidateGeneSet != null && !options.candidateGeneSet.isEmpty()) {
                if (uniqueGenome.getGeneNum() > 0) {
                    assG11 = new AnnotationSummarySet("IsCandidateGene", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                    uniqueGenome.addmRNAFeatureLabel("IsCandidateGene");
                } else if (uniqueGenome.getVarNum() > 0) {
                    assV12 = new AnnotationSummarySet("IsWithinCandidateGene", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                    uniqueGenome.addVariantFeatureLabel("IsWithinCandidateGene");
                }

                String ppiDBFile = null;
                String pathwayDBFile = null;
                if (options.ppidb != null) {
                    ppiDBFile = GlobalManager.RESOURCE_PATH + "/PPI.txt.gz";
                    if (uniqueGenome.getGeneNum() > 0) {
                        ppiTree = new PPIGraph(ppiDBFile);
                        ppiTree.readPPIItems();
                        assPPIG13 = new AnnotationSummarySet("PPI.txt.gz", null, null, 0, 0, 0, uniqueGenome.getmRNAFeatureNum());
                        uniqueGenome.addmRNAFeatureLabel("PPI");
                    } else if (uniqueGenome.getVarNum() > 0) {
                        ppiTree = new PPIGraph(ppiDBFile);
                        ppiTree.readPPIItems();

                        assPPIV14 = new AnnotationSummarySet("PPI.txt.gz", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                        uniqueGenome.addVariantFeatureLabel("PPI");
                    }
                }

                if (options.pathwaydb != null) {
                    if (options.pathwaydb.equals("cano")) {
                        pathwayDBFile = GlobalManager.RESOURCE_PATH + "/c2.cp.v3.1.symbols.gmt.gz";
                    } else if (options.pathwaydb.equals("cura")) {
                        pathwayDBFile = GlobalManager.RESOURCE_PATH + "/c2.all.v3.1.symbols.gmt.gz";
                    } else if (options.pathwaydb.equals("onco")) {
                        pathwayDBFile = GlobalManager.RESOURCE_PATH + "/c6.all.v3.1.symbols.gmt.gz";
                    } else if (options.pathwaydb.equals("cmop")) {
                        pathwayDBFile = GlobalManager.RESOURCE_PATH + "/c4.all.v3.1.symbols.gmt.gz";
                    } else if (options.pathwaydb.equals("onto")) {
                        pathwayDBFile = GlobalManager.RESOURCE_PATH + "/c5.all.v3.1.symbols.gmt.gz";
                    }

                    if (pathwayDBFile != null) {
                        if (uniqueGenome.getGeneNum() > 0) {
                            CandidateGeneExtender candiGeneExtender = new CandidateGeneExtender();
                            candiGeneExtender.setSeedGeneSet(options.candidateGeneSet);
                            candiGeneExtender.loadPathwayDB(pathwayDBFile, 2, 400);
                            mappedPathes = candiGeneExtender.pickRelevantPathwaysh();

                            assPWG15 = new AnnotationSummarySet("SharedPathway", null, null, 0, 0, 0, uniqueGenome.getmRNAFeatureNum());
                            uniqueGenome.addmRNAFeatureLabel("SharedPathway");
                        } else if (uniqueGenome.getVarNum() > 0) {
                            CandidateGeneExtender candiGeneExtender = new CandidateGeneExtender();
                            candiGeneExtender.setSeedGeneSet(options.candidateGeneSet);
                            candiGeneExtender.loadPathwayDB(pathwayDBFile, 2, 400);
                            mappedPathes = candiGeneExtender.pickRelevantPathwaysh();

                            assPWV16 = new AnnotationSummarySet("SharedPathway", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                            uniqueGenome.addVariantFeatureLabel("SharedPathway");
                        }
                    } else {
                        String info = "The pathway data set name " + options.pathwaydb + " does not exist! So the pathway-based prioritization will be ignored!";
                        LOG.warn(info);
                    }
                }
            }

            AnnotationSummarySet assIBS17d1 = null;
            IntArrayList caeSetID = null;
            if (options.ibsCheckCase >= 0 && options.inputFormat.endsWith("--vcf-file")) {
                caeSetID = new IntArrayList();
                int indiSize = subjectList.size();
                for (int i = 0; i < indiSize; i++) {
                    if (subjectList.get(i).getAffectedStatus() == 2) {
                        caeSetID.add(i);
                    }
                }

                assIBS17d1 = new AnnotationSummarySet("ibs", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                uniqueGenome.addVariantFeatureLabel("LongestIBSRegion");
                uniqueGenome.addVariantFeatureLabel("LongestIBSRegionLength(bp)");
            }

            AnnotationSummarySet assHRC17d2 = null;
            IntArrayList controlSetID = null;
            if (options.homozygousRegionCase >= 0 && options.inputFormat.endsWith("--vcf-file")) {
                if (caeSetID == null) {
                    caeSetID = new IntArrayList();
                    int indiSize = subjectList.size();
                    for (int i = 0; i < indiSize; i++) {
                        if (subjectList.get(i).getAffectedStatus() == 2) {
                            caeSetID.add(i);
                        }
                    }
                }

                controlSetID = new IntArrayList();
                int indiSize = subjectList.size();
                for (int i = 0; i < indiSize; i++) {
                    if (subjectList.get(i).getAffectedStatus() == 1) {
                        controlSetID.add(i);
                    }
                }

                assHRC17d2 = new AnnotationSummarySet("homozygousRegionCase", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                uniqueGenome.addVariantFeatureLabel("LongestHomozygosityRegion");
                uniqueGenome.addVariantFeatureLabel("LongestHomozygosityRegionLength(bp)");
            }

            // as it is fast, i would prefer to read the lenght always. 
            Map<String, Double> geneLengths = null;
            AnnotationSummarySet assGIS17d3 = null;
            AnnotationSummarySet assGOS17d4 = null;
            if (options.geneDBLabels != null) {
                GeneRegionParser grp = new GeneRegionParser();
                // geneLengths =
                // grp.readRefGeneLength(GlobalManager.RESOURCE_PATH + "/" +
                // options.PUBDB_FILE_MAP.get(options.geneDBLabels[0]),
                // options.splicingDis);
                String[] pathes = new String[options.geneDBLabels.length];
                int ii = 0;
                for (String lbs : options.geneDBLabels) {
                    pathes[ii] = GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get(lbs);
                    ii++;
                }
                geneLengths = grp.readMergeRefGeneCodingLength(pathes, options.splicingDis, true);

                // only keep genes in inGeneSet
                if (!options.inGeneSet.isEmpty()) {
                    assGIS17d3 = new AnnotationSummarySet("", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                }

                // only keep genes in outGeneSet
                if (!options.outGeneSet.isEmpty()) {
                    assGOS17d4 = new AnnotationSummarySet("", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                }
            }

            List<String[]> regionItems = null;
            AnnotationSummarySet assIBD17d5 = null;
            if (options.ibdFileName != null) {
                int[] indexes = new int[]{0, 1, 2};
                regionItems = new ArrayList<String[]>();
                File ibdFile = new File(options.ibdFileName);
                LocalFile.retrieveData(ibdFile.getCanonicalPath(), regionItems, indexes, "\t");

                assIBD17d5 = new AnnotationSummarySet(options.ibdFileName, null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                uniqueGenome.addVariantFeatureLabel("IBDRegion");
                uniqueGenome.addVariantFeatureLabel("IBDRegionAnnot");
            }

            AnnotationSummarySet dbScSNV18 = null;
            if (options.dbscSNVAnnote) {
                String dbLabelName = "dbscSNV";

                dbScSNV18 = new AnnotationSummarySet("dbscSNV", LocalFileFunc.getBufferedReader(GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get(dbLabelName)), new StringBuilder(), 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                uniqueGenome.addVariantFeatureLabel("ada_score@dbScSNV" + dbLabelName);
                //skip the head line
                dbScSNV18.getBr().readLine();
            }

            Map<String, String> genePubMedID = new HashMap<String, String>();
            String fileName = "HgncGene.txt";
            File resourceFile = new File(GlobalManager.RESOURCE_PATH + "/" + fileName);
            Map<String, String[]> geneNamesMap = varAnnoter.readGeneNames(resourceFile.getCanonicalPath());//time-consuming line. 
            List<String[]> hitDisCountsGenes = null;
            List<String[]> hitDisCounReads = null;

            List<int[]> triosIDList = null;
            IntArrayList effectiveIndivIDsTrios = null;
            Set<String> caseDoubleHitGenes = null;
            Set<String> controlDoubleHitGenes = null;
            if (options.doubleHitGeneTriosFilter) {
                hitDisCountsGenes = new ArrayList<String[]>();
                hitDisCounReads = new ArrayList<String[]>();
                doubleHitGeneModelFilter19 = new FiltrationSummarySet("DoubleHitModel", uniqueGenome.getVariantFeatureNum());
                doubleHitGeneModelFilter19.initiateAMessage(0, "variant(s) are left after filtered by the double-hit genes using parents' genotypes.");
                caseDoubleHitGenes = new HashSet<String>();
                controlDoubleHitGenes = new HashSet<String>();
                // cluster counts according to phentoypes
                int indivSize = subjectList.size();

                triosIDList = new ArrayList<int[]>();
                varFilter.matchTrioSet(subjectList, triosIDList);
                if (triosIDList.isEmpty()) {
                    String infor = "No recognizable trios for double-hit gene checking!";
                    LOG.error(infor);
                    return;
                }
                List<int[]> tmpTriosIDList = new ArrayList<int[]>();
                int trioSize = triosIDList.size();
                for (int t = 0; t < 3; t++) {
                    for (int j = 0; j < trioSize; j++) {
                        int[] trio = triosIDList.get(j);
                        Individual mIndiv = subjectList.get(trio[0]);
                        if (mIndiv.getAffectedStatus() == t) {
                            tmpTriosIDList.add(trio);
                        }
                    }
                }
                triosIDList.clear();
                triosIDList.addAll(tmpTriosIDList);
                tmpTriosIDList.clear();

//prepare the output format
                List<String> headActual = new ArrayList<String>();
                headActual.add("Gene");
                headActual.add("PubMed");
                headActual.add("ExonLen");
                headActual.add("CaseSyno");
                headActual.add("CaseNonSyno");
                int effectiveIndivSize = 0;

                if (options.countAllPsudoControl) {
                    headActual.add("PseudoControlSyno");
                    headActual.add("PseudoControlNonSyno");
                    headActual.add("PValue");
                }

                List<String> headPhenotype = new ArrayList<String>();
                headPhenotype.add("Disease");
                headPhenotype.add(".");
                headPhenotype.add(".");
                headPhenotype.add(".");
                headPhenotype.add(".");
                if (options.countAllPsudoControl) {
                    headPhenotype.add(".");
                    headPhenotype.add(".");
                    headPhenotype.add(".");
                }

                effectiveIndivIDsTrios = new IntArrayList();
                int setSize = triosIDList.size();
                for (int j = 0; j < setSize; j++) {
                    Individual mIndiv = subjectList.get(triosIDList.get(j)[0]);
                    if (triosIDList.get(j)[0] < 0 || triosIDList.get(j)[1] < 0 || triosIDList.get(j)[2] < 0) {
                        continue;
                    }

                    effectiveIndivIDsTrios.add(j);
                    headActual.add(mIndiv.getLabelInChip());
                    headPhenotype.add(String.valueOf(mIndiv.getAffectedStatus()));
                    effectiveIndivSize++;
                }
                hitDisCountsGenes.add(headActual.toArray(new String[0]));
                hitDisCountsGenes.add(headPhenotype.toArray(new String[0]));
                hitDisCounReads.add(headActual.toArray(new String[0]));
                hitDisCounReads.add(headPhenotype.toArray(new String[0]));

                if (effectiveIndivSize == 0) {
                    String infor = "No valid trios for double-hit gene checking!";
                    LOG.warn(infor);
                    return;
                }
            }

            AnnotationSummarySet assGene20 = null;
            AnnotationSummarySet assVariant20 = null;
            if (options.needAnnotateGene) {
                String fileNameHg = "HgncGene.txt";
                //File resourceFileHg = new File(GlobalManager.RESOURCE_PATH + "/" + fileNameHg);
                if (uniqueGenome.getGeneNum() > 0) {
                    assGene20 = new AnnotationSummarySet(fileNameHg, null, null, 0, 0, 0, uniqueGenome.getmRNAFeatureNum());
                    uniqueGenome.addmRNAFeatureLabel("GeneDescription");
                    uniqueGenome.addmRNAFeatureLabel("Pseudogenes");
                } else if (uniqueGenome.getVarNum() > 0) {
                    assVariant20 = new AnnotationSummarySet(fileNameHg, null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                    uniqueGenome.addVariantFeatureLabel("GeneDescription");
                    uniqueGenome.addVariantFeatureLabel("Pseudogenes");
                }
            }

            AnnotationSummarySet assOmimGene21 = null;
            AnnotationSummarySet assOmimVar21 = null;
            if (options.omimAnnotateGene) {
                //File resourceFile = new File(GlobalManager.RESOURCE_PATH + "/morbidmap.gz");
                if (uniqueGenome.getGeneNum() > 0) {
                    assOmimGene21 = new AnnotationSummarySet("morbidmap.gz", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                    uniqueGenome.addVariantFeatureLabel("DiseaseName(s)MIMid");
                    uniqueGenome.addVariantFeatureLabel("GeneMIMid");
                } else if (uniqueGenome.getVarNum() > 0) {
                    assOmimVar21 = new AnnotationSummarySet("morbidmap.gz", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                    uniqueGenome.addVariantFeatureLabel("DiseaseName(s)MIMid");
                    uniqueGenome.addVariantFeatureLabel("GeneMIMid");
                }
            }

            AnnotationSummarySet assSDA22 = null;
            AnnotationSummarySet assSDF22 = null;
            CNVRegionParser grpSD = null;
            ReferenceGenome refGenomeSD = null;
            if (options.superdupAnnotate) {
                grpSD = new CNVRegionParser();
                refGenomeSD = grpSD.readSuperDupRegions(GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get("superdup"));
                assSDA22 = new AnnotationSummarySet("superdup", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                uniqueGenome.addVariantFeatureLabel("SuperDupKValue");
            } else if (options.superdupFilter) {
                grpSD = new CNVRegionParser();
                refGenomeSD = grpSD.readSuperDupRegions(GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get("superdup"));
                assSDF22 = new AnnotationSummarySet("superdup", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
            }

            AnnotationSummarySet assDGV23 = null;
            CNVRegionParser grpDGV = null;
            ReferenceGenome refGenomeDGV = null;
            if (options.dgvcnvAnnotate) {
                grpDGV = new CNVRegionParser();
                refGenomeDGV = grpDGV.readRefCNVSeq(GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get("dgvcnv"));
                assDGV23 = new AnnotationSummarySet("dgvcnv", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                uniqueGenome.addVariantFeatureLabel("DGVIDs");
                uniqueGenome.addVariantFeatureLabel("CNVSampleSize");
                uniqueGenome.addVariantFeatureLabel("LossCNV");
                uniqueGenome.addVariantFeatureLabel("GainCNV");
            }

            AnnotationSummarySet pubmedSearch24_Gene_Ideo = null;
            AnnotationSummarySet pubmedSearch24_Gene = null;
            AnnotationSummarySet pubmedSearch24_Var_Ideo = null;
            AnnotationSummarySet pubmedSearch24_Var = null;
            List<String[]> ideogramItemsGene = new ArrayList<String[]>();
            List<String[]> ideogramItemsVar = new ArrayList<String[]>();
            List<String> featureLabels = uniqueGenome.getVariantFeatureLabels();
            int driverPredicIndex = -1;
            if (options.meshList != null && !options.meshList.isEmpty()) {
                if (uniqueGenome.getGeneNum() > 0) {
                    if (options.pubmedMiningIdeo) {
                        pubmedSearch24_Gene_Ideo = new AnnotationSummarySet("pubmedMiningIdeoGene", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                        uniqueGenome.addmRNAFeatureLabel("PubMedIDIdeogram");

                        String ideoFileName = GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get("ideogram");
                        File ideoFile = new File(ideoFileName);
                        if (!ideoFile.exists()) {
                            System.out.println(ideoFile.getCanonicalPath() + " does not exist!!");
                            return;//Or ignore this ?
                        }

                        if (options.refGenomeVersion.equals("hg18")) {
                            int[] indexes = new int[]{0, 1, 2, 5, 6};
                            LocalFile.retrieveData(ideoFile.getCanonicalPath(), ideogramItemsGene, indexes, "\t");
                            List<String[]> ideogramItemsTmp = new ArrayList<String[]>();
                            ideogramItemsTmp.addAll(ideogramItemsGene);
                            ideogramItemsGene.clear();
                            for (String[] item : ideogramItemsTmp) {
                                String[] newItem = new String[4];
                                newItem[0] = item[0];
                                newItem[1] = item[1] + item[2];
                                newItem[2] = item[3];
                                newItem[3] = item[4];
                                ideogramItemsGene.add(newItem);
                            }
                        } else if (options.refGenomeVersion.equals("hg19")) {
                            int[] indexes = new int[]{0, 3, 1, 2};
                            LocalFile.retrieveData(ideoFile.getCanonicalPath(), ideogramItemsGene, indexes, "\t");
                            List<String[]> ideogramItemsTmp = new ArrayList<String[]>();
                            ideogramItemsTmp.addAll(ideogramItemsGene);
                            ideogramItemsGene.clear();
                            for (String[] item : ideogramItemsTmp) {
                                String[] newItem = new String[4];
                                newItem[0] = item[0].substring(3);
                                newItem[1] = item[1];
                                newItem[2] = item[2];
                                newItem[3] = item[3];
                                ideogramItemsGene.add(newItem);
                            }
                        }
                    }
                    if (options.pubmedMiningGene) {
                        pubmedSearch24_Gene = new AnnotationSummarySet("pubmedMiningGene", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                        uniqueGenome.addmRNAFeatureLabel("PubMedIDGene");
                    }
                } else if (uniqueGenome.getVarNum() > 0) {
                    if (options.pubmedMiningIdeo) {
                        pubmedSearch24_Var_Ideo = new AnnotationSummarySet("pubmedMiningIdeoVar", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                        uniqueGenome.addVariantFeatureLabel("PubMedIDIdeogram");

                        String ideoFileName = GlobalManager.RESOURCE_PATH + "/" + options.PUBDB_FILE_MAP.get("ideogram");
                        File ideoFile = new File(ideoFileName);
                        if (!ideoFile.exists()) {
                            System.out.println(ideoFile.getCanonicalPath() + " does not exist!!");
                            return;//or ignore?
                        }

                        for (int i = 0; i < featureLabels.size(); i++) {
                            if (featureLabels.get(i).equals("IsCancerDriver_COSMICTrainedModel")) {
                                driverPredicIndex = i;
                            }

                            if (driverPredicIndex >= 0) {
                                break;
                            }
                        }

                        if (options.refGenomeVersion.equals("hg18") || options.refGenomeVersion.equals("hg18")) {
                            int[] indexes = new int[]{0, 1, 2, 5, 6};
                            LocalFile.retrieveData(ideoFile.getCanonicalPath(), ideogramItemsVar, indexes, "\t");
                            List<String[]> ideogramItemsTmp = new ArrayList<String[]>();
                            ideogramItemsTmp.addAll(ideogramItemsVar);
                            ideogramItemsVar.clear();
                            for (String[] item : ideogramItemsTmp) {
                                String[] newItem = new String[4];
                                newItem[0] = item[0];
                                newItem[1] = item[1] + item[2];
                                newItem[2] = item[3];
                                newItem[3] = item[4];
                                ideogramItemsVar.add(newItem);
                            }
                        }
                    }
                    if (options.pubmedMiningGene) {
                        pubmedSearch24_Var = new AnnotationSummarySet("pubmedMiningVar", null, null, 0, 0, 0, uniqueGenome.getVariantFeatureNum());
                        uniqueGenome.addVariantFeatureLabel("PubMedIDVar");

                        for (int i = 0; i < featureLabels.size(); i++) {
                            if (featureLabels.get(i).equals("IsCancerDriver_COSMICTrainedModel")) {
                                driverPredicIndex = i;
                            }

                            if (driverPredicIndex >= 0) {
                                break;
                            }
                        }
                    }
                }
            }

            File annovarFilteredInFile = null;
            BufferedWriter annovarFilteredInFileWriter = null;

            if (options.isANNOVAROut) {                                            
                annovarFilteredInFile = new File(options.outputFileName + ".flt.annovar");
                if(options.outGZ){
                    GZIPOutputStream gzOut=new GZIPOutputStream(new FileOutputStream(annovarFilteredInFile.getCanonicalPath()+".gz"));
                    annovarFilteredInFileWriter = new BufferedWriter(new OutputStreamWriter(gzOut));
                }else{
                    annovarFilteredInFileWriter = new BufferedWriter(new FileWriter(annovarFilteredInFile));
               }   
            }
            
            BufferedWriter bwMapBed = null;       
            int[] savedBinnaryBedVar = new int[2];
            savedBinnaryBedVar[0] = 0;
            savedBinnaryBedVar[1] = 0;
            //RandomAccessFile rafBed = null;
            //FileChannel fileChannelBed = null;
            BufferedOutputStream fileChannelBed=null;
            WritableByteChannel wbcFileBed=null;
            
            if (options.isPlinkBedOut) {
                BufferedWriter bwPed=null;
                if(options.outGZ){
                    GZIPOutputStream gzOut=new GZIPOutputStream(new FileOutputStream(options.outputFileName + ".bim"+".gz"));
                    bwMapBed = new BufferedWriter(new OutputStreamWriter(gzOut));
                    GZIPOutputStream gzOut2=new GZIPOutputStream(new FileOutputStream(options.outputFileName + ".fam"+".gz"));
                    bwPed=new BufferedWriter(new OutputStreamWriter(gzOut2));
                }else{
                    bwMapBed = new BufferedWriter(new FileWriter(options.outputFileName + ".bim"));
                    bwPed = new BufferedWriter(new FileWriter(options.outputFileName + ".fam"));
                } 
                //bwMapBed = new BufferedWriter(new FileWriter(options.outputFileName + ".bim"));
                
               //BufferedWriter bwPed = new BufferedWriter(new FileWriter(options.outputFileName + ".fam"));
                for (Individual indiv : subjectList) {
                    if (indiv == null) {
                        continue;
                    }
                    savedBinnaryBedVar[1]++;
                    bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                            + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
                    bwPed.write("\n");
                }
                bwPed.close();

                File kedFile = new File(options.outputFileName + ".bed");
                if (kedFile.exists()) {
                    kedFile.delete();
                }
                if(options.outGZ){
                    wbcFileBed=Channels.newChannel(new FileOutputStream(kedFile.getCanonicalPath()+".gz"));
                    fileChannelBed=new BufferedOutputStream(new GZIPOutputStream(Channels.newOutputStream(wbcFileBed)));  
                    //bwFileChannelBed=new BufferedWriter(new OutputStreamWriter(new GZIPOutputStream(Channels.newOutputStream(wbcFileBed))));
                }else{
                    wbcFileBed=Channels.newChannel(new FileOutputStream(kedFile));
                    fileChannelBed=new BufferedOutputStream(Channels.newOutputStream(wbcFileBed));
                }
                                             
//                rafBed = new RandomAccessFile(kedFile, "rw");
//                fileChannelBed = rafBed.getChannel();
                
//                rafKed = Channels.newChannel(new FileOutputStream(kedFile));
//                fileChannelKed = new BufferedOutputStream(new GZIPOutputStream(Channels.newOutputStream(rafKed)));

                int bufSize = 1024;
                ByteBuffer byteBuffer = ByteBuffer.allocate(bufSize);
                //|-magic number-
                //01101100 00011011
                byte byteInfo = (byte) 0x6C;
                byteBuffer.put(byteInfo);
                byteInfo = (byte) 0x1B;
                byteBuffer.put(byteInfo);
                //|-mode-| 00000001 (SNP-major)
                //00000001 
                byteInfo = 1;

                byteBuffer.put(byteInfo);
                byteBuffer.flip();
                fileChannelBed.write(byteBuffer.array());
                byteBuffer.clear();
            }

            BufferedWriter bwMapPed = null;
            int[] savedPedVar = new int[2];
            savedPedVar[0] = 0;
            savedPedVar[1] = 0;
            if (options.isPlinkPedOut) {
                BufferedWriter bwPed = null;
                if (options.outGZ) {
                    GZIPOutputStream gzOut=new GZIPOutputStream(new FileOutputStream(options.outputFileName + ".map"+".gz"));
                    bwMapPed = new BufferedWriter(new OutputStreamWriter(gzOut));
                    GZIPOutputStream gzOut2=new GZIPOutputStream(new FileOutputStream(options.outputFileName + ".ped.p"+".gz"));
                    bwPed=new BufferedWriter(new OutputStreamWriter(gzOut2));
                } else {
                    bwMapPed = new BufferedWriter(new FileWriter(options.outputFileName + ".map"));
                    bwPed = new BufferedWriter(new FileWriter(options.outputFileName + ".ped.p"));
                }
                //bwPed = new BufferedWriter(new FileWriter(options.outputFileName + ".ped.p"));
                for (Individual indiv : subjectList) {
                    if (indiv == null) {
                        continue;
                    }
                    savedPedVar[1]++;
                    bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                            + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
                    bwPed.write("\n");
                }
                bwPed.close();
            }

            BufferedOutputStream fileChannelKed = null;
            WritableByteChannel rafKed = null;
            BufferedWriter bwMapKed = null;
            int[] savedBinnaryKedVar = new int[2];
            savedBinnaryKedVar[0] = 0;

            if (options.isBinaryGtyOut) {
                File kedFile = new File(options.outputFileName + ".ked.gz");
                if (kedFile.exists()) {
                    kedFile.delete();
                }               

                rafKed = Channels.newChannel(new FileOutputStream(kedFile));
                fileChannelKed = new BufferedOutputStream(new GZIPOutputStream(Channels.newOutputStream(rafKed)));

                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                //|-magic number-
                //10011110 10000010 
                byte byteInfo = (byte) 0x9E;
                byteBuffer.put(byteInfo);
                byteInfo = (byte) 0x82;
                byteBuffer.put(byteInfo);
                //|-mode-| Mode of 00000000 indicates unphased genotypes while that of 00000001 indicates the phased genotypes
                //00000000 
                if (uniqueGenome.isIsPhasedGty()) {
                    byteInfo = 1;
                } else {
                    byteInfo = 0;
                }

                byteBuffer.put(byteInfo);
                byteBuffer.flip();
                fileChannelKed.write(byteBuffer.array());
                byteBuffer.clear();
//pedigree 
                BufferedWriter bwPed = null;
                if (options.outGZ) {
                    GZIPOutputStream gzOut2=new GZIPOutputStream(new FileOutputStream(options.outputFileName + ".fam"+".gz"));
                    bwPed=new BufferedWriter(new OutputStreamWriter(gzOut2));
                } else {
                    bwPed = new BufferedWriter(new FileWriter(options.outputFileName + ".fam"));
                }
                for (Individual indiv : subjectList) {
                    if (indiv == null) {
                        continue;
                    }
                    savedBinnaryKedVar[1]++;
                    bwPed.write(indiv.getFamilyID() + " " + indiv.getIndividualID() + " " + indiv.getDadID()
                            + " " + indiv.getMomID() + " " + indiv.getGender() + " " + indiv.getAffectedStatus());
                    bwPed.write("\n");
                }
                bwPed.close();
                
                //bwMapKed = new BufferedWriter(new FileWriter(options.outputFileName + ".kim"));//For isBinaryGtyOut. 
                if (options.outGZ) {
                    GZIPOutputStream gzOut=new GZIPOutputStream(new FileOutputStream(options.outputFileName + ".kim"+".gz"));
                    bwMapKed=new BufferedWriter(new OutputStreamWriter(gzOut));
                } else {
                    bwMapKed = new BufferedWriter(new FileWriter(options.outputFileName + ".kim"));
                }
            }

            File vcfFilteredInFile = null;
            BufferedWriter vcfFilteredInFileWriter = null;
            if (options.isVCFOut) {
                vcfFilteredInFile = new File(options.outputFileName + ".flt.vcf");
                if(options.outGZ){
                    GZIPOutputStream gzOut=new GZIPOutputStream(new FileOutputStream(vcfFilteredInFile.getCanonicalPath()+".gz"));
                    vcfFilteredInFileWriter = new BufferedWriter(new OutputStreamWriter(gzOut));
                }else{
                    vcfFilteredInFileWriter = new BufferedWriter(new FileWriter(vcfFilteredInFile));
                } 
                //vcfFilteredInFileWriter = new BufferedWriter(new FileWriter(vcfFilteredInFile));
                vcfFilteredInFileWriter.write(vsParser.getVcfHead().toString());
                vcfFilteredInFileWriter.write("#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT");
                for (Individual indiv : subjectList) {
                    vcfFilteredInFileWriter.write("\t");
                    vcfFilteredInFileWriter.write(indiv.getLabelInChip());
                }
                vcfFilteredInFileWriter.write("\n");
            }
            
            boolean needWriteTmp = true;
            BufferedWriter tmpWriter = null;
            if (needWriteTmp) {
                tmpWriter = new BufferedWriter(new FileWriter(options.outputFileName + ".maf"));
                tmpWriter.write("chr	pos	ref_allele	newbase	classification	count\n");
            }

            BufferedWriter finalExportWriter=null;
            if (options.excelOut) {
                // finalFilteredInFile = new File(options.outputFileName +
                // ".flt.xls");
                finalFilteredInFile = new File(options.outputFileName + ".flt.xlsx.tmp");
                finalExportWriter = new BufferedWriter(new FileWriter(finalFilteredInFile));
            } else {
                finalFilteredInFile = new File(options.outputFileName + ".flt.txt");
                if(options.outGZ){
                    GZIPOutputStream gzOut=new GZIPOutputStream(new FileOutputStream(finalFilteredInFile.getCanonicalPath()+".gz"));
                    finalExportWriter = new BufferedWriter(new OutputStreamWriter(gzOut));
                }else{
                    vcfFilteredInFileWriter = new BufferedWriter(new FileWriter(vcfFilteredInFile));
                }                
            }

            //BufferedWriter finalExportWriter = new BufferedWriter(new FileWriter(finalFilteredInFile));

            Genome refhapGenome = null;
            List<Individual> refIndivList = null;
            BufferedWriter bwMap = null;
            FileChannel fileChannel = null;
            int[] coutVar = new int[1];
            int[] intsSPV = new int[2];
            int[] intsIndiv = new int[1];

            if (options.mergeGtyDb != null && (options.isPlinkPedOut || options.isPlinkBedOut)) {
                refIndivList = new ArrayList<Individual>();
                String vcfFilePath = GlobalManager.RESOURCE_PATH + "/" + options.mergeGtyDb + ".chr_CHROM_.vcf.gz";
                vsParser.extractSubjectIDsVCFInFile(vcfFilePath.replaceAll("_CHROM_", "1"), refIndivList);

                refhapGenome = vsParser.readVariantGtyFilterOnly(null, options.threadNum, null, vcfFilePath, options.seqQual, options.minMappingQuality, options.maxStandBias,
                        options.maxFisherStandBias, options.maxGtyAlleleNum, options.gtyQual, options.minGtySeqDP, options.maxAltAlleleFracRefHom, options.minAltAlleleFractHet,
                        options.minAltAlleleFractAltHom, options.vcfFilterLabelsIn, options.minOBS, options.sampleMafOver, options.sampleMafLess, options.considerSNV, options.considerIndel,
                        options.gtySecPL, options.gtyBestGP, options.needProgressionIndicator, false, false, false, false, null, null);

                if (!subjectList.isEmpty() && !refIndivList.isEmpty()) {
                    if (options.isPlinkBedOut) {
                        coutVar[0] = 0;
                        intsIndiv[0] = 0;
                        
                        if(options.outGZ){
                            GZIPOutputStream gzOut=new GZIPOutputStream(new FileOutputStream(options.outputFileName + ".merged.bim"+".gz"));
                            bwMap = new BufferedWriter(new OutputStreamWriter(gzOut));
                        }else{
                            bwMap = new BufferedWriter(new FileWriter(options.outputFileName + ".merged.bim"));
                        }
                        
                        File kedFile = new File(options.outputFileName + ".merged.bed");
                        if (kedFile.exists()) {
                            kedFile.delete();
                        }
                        RandomAccessFile rafKed2 = new RandomAccessFile(kedFile, "rw");
                        fileChannel = rafKed2.getChannel();
                        uniqueGenome.exportPlinkBinaryGty_Fam(subjectList, refIndivList, options.outputFileName, intsIndiv);
                    }

                    if (options.isPlinkPedOut) {
                        intsSPV[0] = 0;
                        intsSPV[1] = 0;
                        
                        if(options.outGZ){
                            GZIPOutputStream gzOut=new GZIPOutputStream(new FileOutputStream(options.outputFileName + ".merged.map"+".gz"));
                            bwMap = new BufferedWriter(new OutputStreamWriter(gzOut));
                        }else{
                            bwMap = new BufferedWriter(new FileWriter(options.outputFileName + ".merged.map"));
                        }
                        
                    }
                }

            }

//*********************************************************************************************************************************************************************//
//-------------------------------------------------------------------Start to filter or annotate 
            Chromosome[] chromosomes = uniqueGenome.getChromosomes();

            int leftVar = -1;
            boolean needHead = true;
            List<Variant> chromosomeVarAll = new ArrayList<Variant>();
            int finalVarNum = 0;
            for (int chromID = 0; chromID < chromosomes.length; chromID++) {
                uniqueGenome.loadVariantFromDisk(chromID);//time-consuming part. 
                List<Variant> chromosomeVar = chromosomes[chromID].variantList;
                if (chromosomeVar == null || chromosomeVar.isEmpty()) {
                    continue;
                }

                chromosomeVarAll.addAll(chromosomeVar);
                //More variant QC
                varFilter.sumFilterCaseControlVar(chromosomes[chromID], options.minHetA, options.minHomA, options.minHetU, options.minHomU, options.minOBSA, options.minOBSU, minMissingQCFilter1);
                if (chromosomeVar.isEmpty()) {
                    //   LOG.info("0 sequence variant(s) are left finally!");
                }

                if (inheritanceModelFilter2 != null) {
                    varFilter.inheritanceModelFilterVar(chromosomes[chromID], uniqueGenome.isIsPhasedGty(), subjectList, genotypeFilters, hardFilterModel, inheritanceModelFilter2);
                }
                if (denovoModelFilter3 != null) {
                    varFilter.devnoMutationFilterVar(chromosomes[chromID], uniqueGenome.isIsPhasedGty(), subjectList, setSampleIDList, options.noHomo, denovoModelFilter3);
                }

                if (needGty && options.sampleGtyHardFilterCode != null && (options.sampleGtyHardFilterCode.contains("8"))) {
                    varFilter.somaticMutationFilterVar(chromosomes[chromID], uniqueGenome.isIsPhasedGty(), subjectList, setSampleIDList, setSampleLabelList, somaticModelFilter4, options.somatReadsP);
                }

                if (options.sampleVarHardFilterCode != null && options.sampleVarHardFilterCode.equals("association") && options.inputFormat.endsWith("--vcf-file")) {
                    varFilter.filterBy4ModelPValue(chromosomes[chromID], assSVHF, thrholds, uniqueGenome);
                }

                if (varaintDBHardFilterFiles5 != null) {
                    for (int i = 0; i < varaintDBHardFilterFiles5.length; i++) {
                        leftVar = varAnnoter.hardFilterByANNOVARefFormat(chromosomes[chromID], chromID, varaintDBHardFilterFiles5[i], options.needProgressionIndicator);
                        if (leftVar == 0) {
                            break;
                        }
                        chromosomes[chromID].buildVariantIndexMap();
                    }
                }

                if (varaintDBFilterFiles6 != null) {
                    for (int i = 0; i < varaintDBFilterFiles6.length; i++) {
                        varAnnoter.markByANNOVARefFormat(chromosomes[chromID], chromID, varaintDBFilterFiles6[i], options.needProgressionIndicator);
                    }
                }

                if (referenceGenomes != null) {
                    for (int i = 0; i < referenceGenomes.length; i++) {
                        varAnnoter.geneFeatureAnnot(chromosomes[chromID], chromID, referenceGenomes[i], options.geneFeatureIn, availableFeatureSizeForGeneDB[i]);
                    }
                    //this should not be filttered by gene-feature
                    varAnnoter.summarizeVarPerGene(chromosomes[chromID], somatNumIndex, readInfoIndex);
                    varFilter.geneFeatureFilter(chromosomes[chromID], variantsCounters, options.geneFeatureIn, geneDBFilter7);
                }

                if (dbNSFPAnnot8 != null) {
                    for (String dbLabelName : options.scoreDBLableList) {
                        if (dbLabelName.equals("dbnsfp")) {
                            String dbFileName = options.PUBDB_FILE_MAP.get(dbLabelName);
                            varAnnoter.readExonicScoreNSFPNucleotideMerge(chromosomes[chromID], GlobalManager.RESOURCE_PATH + "/" + dbFileName, options.refGenomeVersion,
                                    dbNSFP3ScoreIndexes, dbNSFP3PredicIndex, dbNSFPAnnot8, options.needProgressionIndicator);
                        }

                        if (options.causingPredType == 0) {
//riskPredictionRareDiseaseAll(Chromosome chromosome, List<CombOrders> combOrderList, boolean filterNonDisMut, List<String> names, FiltrationSummarySet dbNSFPPred9)
                            if (options.predictExplanatoryVar.startsWith("all")) {
                                varAnnoter.riskPredictionRareDiseaseAll(chromosomes[chromID], combOrderList, options.filterNonDiseaseMut, uniqueGenome.getScoreLabels(), options.threadNum, dbNSFPPred9);
                            } else if (options.predictExplanatoryVar.startsWith("best")) {
                                varAnnoter.riskPredictionRareDiseaseBest(chromosomes[chromID], combOrderList, options.filterNonDiseaseMut, uniqueGenome.getScoreLabels(), dbNSFPPred9);
                            } else {
                                varAnnoter.riskPredictionRareDiseaseFixParam(chromosomes[chromID], fixedComb, options.filterNonDiseaseMut, uniqueGenome.getScoreLabels(), dbNSFPPred9);
                            }
                        } else if (options.causingPredType == 2) {
                            //Chromosome chromosome, MyRandomForest myRandomForest, boolean filterNonDisMut, FiltrationSummarySet dbNSFPPred9
                            varAnnoter.riskPredictionRandomForest(chromosomes[chromID], myRandomForest, options.threadNum, options.filterNonDiseaseMut, dbNSFPPred9);
                        }
                    }
                }

                if (options.geneVarFilter > 0) {
                    varFilter.filterByGeneVarNum(chromosomes[chromID], assGVF10, options.geneVarFilter, uniqueGenome.getVariantFeatureLabels(), uniqueGenome.isIsPhasedGty());
                }

                if (options.candidateGeneSet != null && !options.candidateGeneSet.isEmpty()) {
                    if (uniqueGenome.getGeneNum() > 0) {
                        varAnnoter.canidateGeneExploreGene(chromosomes[chromID], assG11, options.candidateGeneSet);
                    } else if (uniqueGenome.getVarNum() > 0) {
                        varAnnoter.canidateGeneExploreVar(chromosomes[chromID], assV12, options.candidateGeneSet);
                    }

                    if (options.ppidb != null) {
                        if (uniqueGenome.getGeneNum() > 0) {
                            varAnnoter.canidateGenePPIExploreGene(chromosomes[chromID], assPPIG13, options.candidateGeneSet, ppiTree, options.ppiDepth);
                        } else if (uniqueGenome.getVarNum() > 0) {
                            varAnnoter.canidateGenePPIExploreVar(chromosomes[chromID], assPPIV14, options.candidateGeneSet, ppiTree, options.ppiDepth);
                        }
                    }

                    if (mappedPathes != null) {
                        if (uniqueGenome.getGeneNum() > 0) {
                            varAnnoter.canidateGenePathwayExploreGene(chromosomes[chromID], assPWG15, options.candidateGeneSet, mappedPathes);
                        } else if (uniqueGenome.getVarNum() > 0) {
                            varAnnoter.canidateGenePathwayExploreVar(chromosomes[chromID], assPWV16, options.candidateGeneSet, mappedPathes);
                        }
                    }
                }

                if (options.ibsCheckCase >= 0 && options.inputFormat.endsWith("--vcf-file")) {
                    varAnnoter.exploreLongIBSRegion(chromosomes[chromID], assIBS17d1, chromosomeVarAll, caeSetID, options.ibsCheckCase * 1000, uniqueGenome.isIsPhasedGty(), subjectList);
                }

                if (options.homozygousRegionCase >= 0 && options.inputFormat.endsWith("--vcf-file")) {
                    varAnnoter.exploreLongHomozygosityRegion(chromosomes[chromID], assHRC17d2, chromosomeVarAll, caeSetID, controlSetID, options.homozygousRegionCase * 1000, uniqueGenome.isIsPhasedGty(), subjectList);
                }

                if (options.geneDBLabels != null) {
                    if (!options.inGeneSet.isEmpty()) {
                        varFilter.keepGenesInSet(chromosomes[chromID], assGIS17d3, options.inGeneSet);
                    }

                    // only keep genes in outGeneSet
                    if (!options.outGeneSet.isEmpty()) {
                        varFilter.keepGenesOutSet(chromosomes[chromID], assGOS17d4, options.outGeneSet);
                    }
                }

                if (options.ibdFileName != null) {
                    varAnnoter.ibdRegionExplore(chromosomes[chromID], assIBD17d5, regionItems);
                }

                if (dbScSNV18 != null) {
                    varAnnoter.dbscSNV(chromosomes[chromID], dbScSNV18, options.needProgressionIndicator);
                }

                // System.out.println(chromID);
                if (doubleHitGeneModelFilter19 != null) {
                    varFilter.doubleHitGeneExploreVarTriosSudoControl(chromosomes[chromID], uniqueGenome.isIsPhasedGty(), subjectList, triosIDList, effectiveIndivIDsTrios, options.meshList, geneNamesMap, genePubMedID,
                            options.noHomo, hitDisCountsGenes, hitDisCounReads, caseDoubleHitGenes, controlDoubleHitGenes, options.countAllPsudoControl, doubleHitGeneModelFilter19);
                }

                if (options.needAnnotateGene) {
                    String fileNameHg = "HgncGene.txt";
                    File resourceFileHg = new File(GlobalManager.RESOURCE_PATH + "/" + fileNameHg);
                    if (uniqueGenome.getGeneNum() > 0) {
                        varAnnoter.pseudogeneAnnotationGene(chromosomes[chromID], assGene20, resourceFileHg.getCanonicalPath());
                    } else if (uniqueGenome.getVarNum() > 0) {
                        varAnnoter.pseudogeneAnnotationVar(chromosomes[chromID], assVariant20, resourceFileHg.getCanonicalPath());
                    }
                }

                if (options.omimAnnotateGene) {
                    File resourceFileOmim = new File(GlobalManager.RESOURCE_PATH + "/morbidmap.gz");
                    if (uniqueGenome.getGeneNum() > 0) {
                        varAnnoter.omimGeneAnnotationGene(chromosomes[chromID], assOmimGene21, resourceFileOmim.getCanonicalPath());
                    } else if (uniqueGenome.getVarNum() > 0) {
                        varAnnoter.omimGeneAnnotationVar(chromosomes[chromID], assOmimVar21, resourceFile.getCanonicalPath());
                    }
                }

                if (options.superdupAnnotate) {
                    varAnnoter.superDupAnnotation(chromosomes[chromID], assSDA22, refGenomeSD);
                } else if (options.superdupFilter) {
                    varFilter.superDupFilter(chromosomes[chromID], assSDF22, refGenomeSD);
                    if (uniqueGenome == null || uniqueGenome.getVarNum() == 0) {
                        LOG.info("0 sequence variant(s) are left finally!");
                        return;
                    }
                }

                if (options.dgvcnvAnnotate) {
                    varAnnoter.cnvAnnotation(chromosomes[chromID], assDGV23, refGenomeDGV);
                }

                if (options.meshList != null && !options.meshList.isEmpty()) {
                    if (uniqueGenome.getGeneNum() > 0) {
                        if (options.pubmedMiningIdeo) {
                            varAnnoter.pubMedIDIdeogramExploreGene(chromosomes[chromID], pubmedSearch24_Gene_Ideo, options.meshList, ideogramItemsGene);
                        }
                        if (options.pubmedMiningGene) {
                            varAnnoter.pubMedIDGeneExploreGene(chromosomes[chromID], pubmedSearch24_Gene, options.meshList, geneNamesMap, genePubMedID);
                        }
                    } else if (uniqueGenome.getVarNum() > 0) {
                        if (options.pubmedMiningIdeo) {
                            varAnnoter.pubMedIDIdeogramExploreVar(chromosomes[chromID], pubmedSearch24_Var_Ideo, options.meshList, ideogramItemsVar, options.refGenomeVersion, true, driverPredicIndex);
                        }
                        if (options.pubmedMiningGene) {
                            varAnnoter.pubMedIDGeneExploreVar(chromosomes[chromID], pubmedSearch24_Var, options.meshList, true, geneNamesMap, genePubMedID, driverPredicIndex);
                        }
                    }
                }

                if (chromosomeVar.isEmpty()) {
                    continue;
                }
                if (!subjectList.isEmpty()) {
                    if (options.isPlinkBedOut) {
                        uniqueGenome.exportPlinkBinaryGty(chromosomes[chromID], subjectList, fileChannelBed, bwMapBed, savedBinnaryBedVar);
                    }
                    if (options.isBinaryGtyOut) {
                        uniqueGenome.exportKGGSeqBinaryGty(chromosomes[chromID], subjectList, fileChannelKed, bwMapKed, savedBinnaryKedVar);
                    }
                    if (options.isPlinkPedOut) {
                        uniqueGenome.export2FlatTextPlink(chromosomes[chromID], subjectList, bwMapPed, options.outputFileName, savedPedVar,options.outGZ);
                    }
                }
                if (needGty) {
                    // to do something
                    // uniqueGenome.cleanBitGenotype(chromID, subjectList);
                }
                if (needWriteTmp)
                uniqueGenome.export2ATmpFormat(tmpWriter, chromID);
                if (options.isANNOVAROut) {
                    uniqueGenome.export2ANNOVARInput(annovarFilteredInFileWriter, chromID);
                }

                //to release memory, release all lefte variants on this chromosome 
                uniqueGenome.export2FlatText(finalExportWriter, chromID, needHead, options.needRecordAltFreq);
                if (options.needGtyQual) {
                    uniqueGenome.export2VCFFormat(vcfFilteredInFileWriter, chromID, subjectList, options.missingGty);
                }

                if (options.mergeGtyDb != null && (options.isPlinkPedOut || options.isPlinkBedOut)) {
                    if (!subjectList.isEmpty() && !refIndivList.isEmpty()) {
                        if (options.isPlinkBedOut) {
                            uniqueGenome.exportPlinkBinaryGty(refhapGenome.getChromosomes()[chromID], subjectList, fileChannel, bwMap, coutVar);//Write .bim and .bed file
                        }
                        if (options.isPlinkPedOut) {
                            uniqueGenome.export2FlatTextPlink(refhapGenome.getChromosomes()[chromID], subjectList, bwMap, options.outputFileName, intsSPV,options.outGZ);//Write .map and .ped file
                        }
                    }
                }

                finalVarNum += chromosomeVar.size();
                chromosomeVar.clear();
                chromosomes[chromID].getPosIndexMap().clear();
                needHead = false;
                chromosomeVarAll.clear();
            }
            if(needWriteTmp)
            tmpWriter.close();
//************************************************************************************************************************************************************************//
            if (vcfFilteredInFileWriter != null) {
                vcfFilteredInFileWriter.close();
            }
            if (finalExportWriter != null) {
                finalExportWriter.close();
            }
            if (annovarFilteredInFileWriter != null) {
                annovarFilteredInFileWriter.close();
            }

            if (referenceGenomes != null) {
                for (int i = 0; i < referenceGenomes.length; i++) {
                    referenceGenomes[i] = null;
                }
            }
            if (minMissingQCFilter1 != null) {
                String info = minMissingQCFilter1.toString();
                if (!info.isEmpty()) {
                    LOG.info(info);
                }
                minMissingQCFilter1 = null;
            }

            if (inheritanceModelFilter2 != null) {
                String info = inheritanceModelFilter2.toString();
                if (!info.isEmpty()) {
                    LOG.info(info);
                }
                inheritanceModelFilter2 = null;
            }

            if (denovoModelFilter3 != null) {
                String info = denovoModelFilter3.toString();
                if (!info.isEmpty()) {
                    LOG.info(info);
                }
                denovoModelFilter3 = null;
            }

            if (somaticModelFilter4 != null) {
                String info = somaticModelFilter4.toString();
                if (info.isEmpty()) {
                    LOG.info(info);
                }
            }

            if (options.sampleVarHardFilterCode != null && options.sampleVarHardFilterCode.equals("association") && options.inputFormat.endsWith("--vcf-file")) {
                uniqueGenome.setVarNum(assSVHF.getAnnotNum());
                String info = assSVHF.getAnnotNum() + " variant(s) with p valus <= the above p-value cutoffs are left!";
                LOG.info(info);
            }

            if (varaintDBHardFilterFiles5 != null) {
                for (int i = 0; i < varaintDBHardFilterFiles5.length; i++) {
                    varaintDBHardFilterFiles5[i].getBr().close();
                    String info = varaintDBHardFilterFiles5[i].getLeftNum() + " variant(s) are left after hard filtering in database " + varaintDBHardFilterFiles5[i].getName() + ", which contains " + varaintDBHardFilterFiles5[i].getTotalNum() + " effective variants.";
                    LOG.info(info);
                    varaintDBHardFilterFiles5[i] = null;
                }
            }

            if (varaintDBFilterFiles6 != null) {
                for (int i = 0; i < varaintDBFilterFiles6.length; i++) {
                    varaintDBFilterFiles6[i].getBr().close();
                    String info = varaintDBFilterFiles6[i].getLeftNum() + " variant(s) exist in " + varaintDBFilterFiles6[i].getName() + ", which contains " + varaintDBFilterFiles6[i].getTotalNum() + " effective variants.";
                    LOG.info(info);
                    varaintDBFilterFiles6[i] = null;
                }
            }

            if (variantsCounters != null) {
                double totolVarNum = 0;
                for (int num : variantsCounters) {
                    totolVarNum += num;
                }
                StringBuilder info = new StringBuilder();
                info.append('\n');
                for (int i = 0; i < VAR_FEATURE_NAMES.length; i++) {
                    info.append(i).append(".").append(VAR_FEATURE_NAMES[i]).append(": ").append(variantsCounters[i]).append(" (")
                            .append(Util.doubleToString(variantsCounters[i] * 100 / totolVarNum, 3)).append("%)\n");
                }
                LOG.info(info);
                LOG.info(geneDBFilter7.toString());
            }

            if (dbNSFPAnnot8 != null) {
                String info = dbNSFPAnnot8.toString();
                if (!info.isEmpty()) {
                    LOG.info(info);
                }
            }

            if (dbNSFPPred9 != null) {
                LOG.info(dbNSFPPred9.toString(0, 3, " "));
                String info = dbNSFPPred9.toString(3, 4, "");
                if (!info.isEmpty()) {
                    LOG.info(info);
                }
            }

            if (options.geneVarFilter > 0) {
                StringBuilder info = new StringBuilder();
                info.append(assGVF10.getLeftNum()).append(" variant(s) are left after filtered by genes with ").append(options.geneVarFilter).append(" or over variants!");
                LOG.info(info);
                uniqueGenome.setVarNum(assGVF10.getLeftNum());
            }

            if (options.candidateGeneSet != null && !options.candidateGeneSet.isEmpty()) {
                if (uniqueGenome.getGeneNum() > 0) {
                    String strInfo = assG11.getName() + ": " + assG11.getAnnotNum() + " mRNAs belong to the candidate gene set.";
                    LOG.info(strInfo);
                } else if (uniqueGenome.getVarNum() > 0) {
                    String strInfo = assV12.getName() + ": " + assV12.getAnnotNum() + " variants are within candidate gene set.";
                    LOG.info(strInfo);
                }
                if (options.ppidb != null) {
                    if (uniqueGenome.getGeneNum() > 0) {
                        String strInfo = assPPIG13.getName() + ": " + assPPIG13.getAnnotNum() + " mRNAs belong to the candidate gene set.";
                        LOG.info(strInfo);
                    } else if (uniqueGenome.getVarNum() > 0) {
                        LOG.info(assPPIV14.getAnnotNum() + " sequence variant(s) are highlighted by PPI information!");
                    }
                }

                if (options.pathwaydb != null) {
                    if (mappedPathes != null) {
                        if (uniqueGenome.getGeneNum() > 0) {
                            LOG.info(assPWG15.getName() + ": " + assPWG15.getAnnotNum() + " mRNAs are involved into the related pathway.");
                        } else if (uniqueGenome.getVarNum() > 0) {
                            LOG.info(assPWV16.getAnnotNum() + " sequence variant(s) are highlighted by GeneSet/Pathway information!");
                        }
                    }
                }
            }

            if (options.ibsCheckCase >= 0 && options.inputFormat.endsWith("--vcf-file")) {
                uniqueGenome.setVarNum(assIBS17d1.getAnnotNum());
                LOG.info(assIBS17d1.getAnnotNum() + " variant(s) are left after filtered by IBS filtering!");
                if (uniqueGenome == null || uniqueGenome.getVarNum() == 0) {
                    LOG.info("0 sequence variant(s) are left finally!");
                    return;
                }
            }

            if (options.homozygousRegionCase >= 0 && options.inputFormat.endsWith("--vcf-file")) {
                uniqueGenome.setVarNum(assHRC17d2.getAnnotNum());
                LOG.info(assHRC17d2.getAnnotNum() + " variant(s) are left after filtered by Homozygosity filtering!");
                if (uniqueGenome == null || uniqueGenome.getVarNum() == 0) {
                    LOG.info("0 sequence variant(s) are left finally!");
                    return;
                }
            }

            // only keep genes in inGeneSet
            if (options.geneDBLabels != null) {
                if (!options.inGeneSet.isEmpty()) {
                    StringBuilder info = new StringBuilder();
                    info.append(assGIS17d3.getAnnotNum()).append(" variant(s) are left after filtering those outside specified genes!");
                    LOG.info(info);
                    uniqueGenome.setVarNum(assGIS17d3.getAnnotNum());
                }

                // only keep genes in outGeneSet
                if (!options.outGeneSet.isEmpty()) {
                    StringBuilder info = new StringBuilder();
                    info.append(assGOS17d4.getAnnotNum()).append(" variant(s) are left after filtering those inside specified genes!");
                    LOG.info(info);
                    uniqueGenome.setVarNum(assGOS17d4.getAnnotNum());
                }
            }

            if (options.ibdFileName != null) {
                LOG.info(assIBD17d5.getLeftNum() + " variant(s) are left after filtered by IBD Region filtering!");
            }

            if (dbScSNV18 != null) {
                dbScSNV18.getBr().close();
                String info = dbScSNV18.getLeftNum() + " variant(s) exist in " + dbScSNV18.getName() + ", which contains " + dbScSNV18.getTotalNum() + " effective variants.";
                LOG.info(info);
                dbScSNV18 = null;
            }

            if (doubleHitGeneModelFilter19 != null) {
                int hitGenenNum = hitDisCountsGenes.size();
                for (int i = 2; i < hitGenenNum; i++) {
                    String[] row = hitDisCountsGenes.get(i);
                    Double lens = geneLengths.get(row[0]);
                    if (lens == null) {
                        row[2] = "0";
                        hitDisCountsGenes.get(i)[2] = row[2];
                        hitDisCounReads.get(i)[2] = row[2];
                    } else {
                        row[2] = String.valueOf(lens);
                        hitDisCountsGenes.get(i)[2] = row[2];
                        hitDisCounReads.get(i)[2] = row[2];
                    }

                }

                StringBuilder info = new StringBuilder();
                String info1 = doubleHitGeneModelFilter19.toString();
                if (info1.isEmpty()) {
                    info.append(info1).append('\n');
                }

                String outFileName = options.outputFileName + ".doublehit.gene.trios.flt";

                List<List<String[]>> arrys = new ArrayList<List<String[]>>();

                arrys.add(hitDisCountsGenes);
                arrys.add(hitDisCounReads);

                if (options.excelOut) {
                    List<String> sheetLabels = new ArrayList<String>();
                    sheetLabels.add("counts");
                    sheetLabels.add("genotypes");

                    File savedFile = new File(outFileName + ".xlsx");
                    LocalExcelFile.writeMultArray2XLSXFile(savedFile.getCanonicalPath(), arrys, sheetLabels, true, 0);
                    info.append("All POSSIBLE double-hit genes are saved in ").append(savedFile.getCanonicalPath()).append(".");
                } else {
                    File savedFile1 = new File(outFileName + ".count.txt");
                    LocalFile.writeData(savedFile1.getCanonicalPath(), arrys.get(0), "\t", false);
                    File savedFile2 = new File(outFileName + ".gty.txt");
                    LocalFile.writeData(savedFile2.getCanonicalPath(), arrys.get(1), "\t", false);
                    info.append("All POSSIBLE double-hit genes are saved in ").append(savedFile1.getCanonicalPath()).append(" and ").append(savedFile2.getCanonicalPath()).append(".");
                }

                info.append("\nThe double-hit genes:\n");
                if (!caseDoubleHitGenes.isEmpty()) {
                    info.append("in cases: ").append(caseDoubleHitGenes.size()).append("\n").append(caseDoubleHitGenes.toString()).append("\n");
                }
                LOG.info(info);
            }

            if (options.needAnnotateGene) {
                if (uniqueGenome.getGeneNum() > 0) {
                    String strInfo = assGene20.getName() + ": " + assGene20.getAnnotNum() + " variants are annotated out of " + assGene20.getTotalNum() + "variants, and " + assGene20.getLeftNum() + " variants are left.";
                    LOG.info(strInfo);
                } else if (uniqueGenome.getVarNum() > 0) {
                    String strInfo = assVariant20.getName() + ": " + assVariant20.getAnnotNum() + " variants are annotated out of " + assVariant20.getTotalNum() + "variants, and " + assVariant20.getLeftNum() + " variants are left.";
                    LOG.info(strInfo);
                }
            }

            if (options.omimAnnotateGene) {
                if (uniqueGenome.getGeneNum() > 0) {
                    String strInfo = assOmimGene21.getName() + ": " + assOmimGene21.getAnnotNum() + " variants are annotated out of " + assOmimGene21.getTotalNum() + "variants, and " + assOmimGene21.getLeftNum() + " variants are left.";
                    LOG.info(strInfo);
                } else if (uniqueGenome.getVarNum() > 0) {
                    LOG.info(assOmimVar21.getAnnotNum() + " sequence variant(s) are highlighted by OMIM information!");
                }
            }

            if (options.superdupAnnotate) {
                String info = assSDA22.getLeftNum() + " variant(s) are in super-duplicated regions registered in a data set genomicSuperDups table of UCSC";
                LOG.info(info);
            } else if (options.superdupFilter) {
                uniqueGenome.setVarNum(assSDF22.getLeftNum());
                LOG.info(assSDF22.getAnnotNum() + " variant(s) are left after filtering those in super-duplicated regions registered in a data set genomicSuperDups table of UCSC!");
            }

            if (options.dgvcnvAnnotate) {
                StringBuilder info = new StringBuilder();
                info.append('\n');
                LOG.info(info);
                LOG.info(assDGV23.getLeftNum() + " variant(s) are in large copy-number variation (CNV) regions registered in Database of Genomic Variants http://projects.tcag.ca/variation/.");
            }

            if (options.meshList != null && !options.meshList.isEmpty()) {
                if (uniqueGenome.getGeneNum() > 0) {
                    if (options.pubmedMiningIdeo) {

                    }
                    if (options.pubmedMiningGene) {
                        LOG.info(pubmedSearch24_Gene.getAnnotNum() + " genes are highlighted by Pubmed information!");
                    }
                } else if (uniqueGenome.getVarNum() > 0) {
                    if (options.pubmedMiningIdeo) {

                    }
                    if (options.pubmedMiningGene) {
                        LOG.info(pubmedSearch24_Var.getAnnotNum() + " sequence variant(s) are highlighted by Pubmed information!");
                    }
                }
            }
            
            if (options.isPlinkBedOut) {
                if (bwMapBed != null) {
                    bwMapBed.close();
                }
                if (fileChannelBed != null) {
                    fileChannelBed.close();
                    //rafBed.close();
                }
                String info = "Genotype of " + savedBinnaryBedVar[0] + " sequence variant(s) and " + subjectList.size() + " individuals are saved \nin "
                        + options.outputFileName + ".fam " + options.outputFileName + ".bim " + options.outputFileName + ".bed " + " with Plink binary genotype format.";
                LOG.info(info);
            }

            if (options.isPlinkPedOut) {
                bwMapPed.close();
                //merge   files
                BufferedReader brPed = null;
                if(options.outGZ){
                    brPed = LocalFileFunc.getBufferedReader(options.outputFileName + ".ped.p.gz");
                }else{
                    brPed = LocalFileFunc.getBufferedReader(options.outputFileName + ".ped.p");
                }
                
                File[] files = new File[STAND_CHROM_NAMES.length];
                BufferedReader[] brPedGty = new BufferedReader[STAND_CHROM_NAMES.length];
                for (int i = 0; i < STAND_CHROM_NAMES.length; i++) {                   
                    if(options.outGZ){
                        files[i]=new File(options.outputFileName+".ped."+i+".gz");
                    }else{
                        files[i] = new File(options.outputFileName + ".ped." + i);
                    }
                    if (!files[i].exists()) {
                        continue;
                    }
                    brPedGty[i] = LocalFileFunc.getBufferedReader(files[i].getCanonicalPath());
                }
                
//                BufferedWriter bwPed = LocalFileFunc.getBufferedWriter(options.outputFileName + ".ped", false);
                BufferedWriter bwPed=null;
                if(options.outGZ){
                    GZIPOutputStream gzOut=new GZIPOutputStream(new FileOutputStream(options.outputFileName + ".ped"+".gz"));
                    bwPed = new BufferedWriter(new OutputStreamWriter(gzOut));
                }else{
                    bwPed = LocalFileFunc.getBufferedWriter(options.outputFileName + ".ped", false);
                }
                
                String line;                       
                while ((line = brPed.readLine()) != null) {
                    bwPed.write(line);
                    for (int i = 0; i < STAND_CHROM_NAMES.length; i++) {
                        if (!files[i].exists()) {
                            continue;
                        }
                        bwPed.write(brPedGty[i].readLine());
                    }
                    bwPed.write('\n');
                }
                brPed.close();
                bwPed.close();

                //file.delete();
                for (int i = 0; i < STAND_CHROM_NAMES.length; i++) {
                    if (!files[i].exists()) {
                        continue;
                    }
                    brPedGty[i].close();
                    files[i].deleteOnExit();
                    //files[i].delete();
                }
                
                File filePedP;
                if(options.outGZ){
                    filePedP = new File(options.outputFileName + ".ped.p.gz");
                }else{
                    filePedP = new File(options.outputFileName + ".ped.p");
                }
                filePedP.deleteOnExit();                
                
                String info = "Genotype of " + savedPedVar[0] + " sequence variant(s) and " + subjectList.size()
                        + " individuals are saved \nin " + options.outputFileName + ".map " + options.outputFileName + ".ped  with Plink pedigree format.";
                LOG.info(info);
            }

            if (options.isBinaryGtyOut) {
                if (bwMapKed != null) {
                    bwMapKed.close();
                }

                if (fileChannelKed != null) {
                    fileChannelKed.close();
                    rafKed.close();
                }
                String info = "Genotype of " + savedBinnaryKedVar[0] + " sequence variant(s) and " + subjectList.size() + " individuals are saved \nin "
                        + options.outputFileName + ".fam " + options.outputFileName + ".kim " + options.outputFileName + ".ked " + " with KGGSseq binary genotype format.";
                LOG.info(info);
            }

            if (options.isANNOVAROut) {
                LOG.info("Final variants are saved in " + annovarFilteredInFile.getCanonicalPath() + " with ANNOVAR format.");
            }

            if (options.excelOut) {
                File finalFilteredInFile1 = new File(options.outputFileName + ".flt.xlsx");
                //As the function of appending data into an existing file is very slow; So I just have convert a text file into an excel file 
                LocalExcelFile.convertTextFile2XLSXFile(finalFilteredInFile.getCanonicalPath(), finalFilteredInFile1.getCanonicalPath(), true, 4);
                //Remove the text file to save storage space
                finalFilteredInFile.delete();
                LOG.info("Finally, " + finalVarNum + " variants are saved in " + finalFilteredInFile1.getCanonicalPath() + " with Excel format.\n\n");
            } else {
                LOG.info("Finally," + finalVarNum + " variants are saved in " + finalFilteredInFile.getCanonicalPath() + " with flat text format.\n\n");
            }

            if (options.mergeGtyDb != null && (options.isPlinkPedOut || options.isPlinkBedOut)) {
                if (!subjectList.isEmpty() && !refIndivList.isEmpty()) {
                    if (options.isPlinkBedOut) {
                        String info = "Genotype of " + coutVar[0] + " sequence variant(s) and " + intsIndiv[0] + " individuals are saved \nin "
                                + options.outputFileName + ".merged.fam " + options.outputFileName + ".merged.bim " + options.outputFileName + ".merged.bed " + " with Plink binary genotype format.";
                        System.out.println(info);
                        bwMap.close();
                        fileChannel.close();
                        rafKed.close();
                    }

                    if (options.isPlinkPedOut) {
                        String info = "Genotype of " + intsSPV[0] + " sequence variant(s) and " + intsSPV[1]
                                + " individuals are saved \nin " + options.outputFileName + ".merged.map " + options.outputFileName + ".merged.ped  with Plink pedigree format.";
                        System.out.println(info);

                    }
                }
            }

            //-----------------------Annotate genes and gene sets on whole genome-------------------------------
            String[] cells = null;
            GeneAnnotator geneAnnotor = new GeneAnnotator();
            Map<String, Map<String, Integer>> cosmicGeneMut = null;
            Map<String, double[]> driverGeneScores = null;
            List<String> scoreNames = new ArrayList<String>();
            if (somaticModelFilter4 != null) {
                String geneCoVarFilePath = options.PUBDB_FILE_MAP.get("cancer.mutsig");
                geneCoVarFilePath = GlobalManager.RESOURCE_PATH + "/" + geneCoVarFilePath;
                driverGeneScores = geneAnnotor.readMutationGeneScore(geneCoVarFilePath, scoreNames);

                if (options.cosmicAnnotate) {
                    fileName = options.PUBDB_FILE_MAP.get("cosmicdb");
                    cosmicGeneMut = geneAnnotor.readCosmicGeneAnnotation(GlobalManager.RESOURCE_PATH + "/" + fileName);
                }
            }
            if (options.causingPredType == 2) {
                geneAnnotor.summarizeSomaticDriverGene(uniqueGenome, geneLengths, cosmicGeneMut, driverGeneScores, scoreNames, options.pathwayHyperGenePCut, options.outputFileName + ".gene.xlsx");
            }
        } finally {
            if (uniqueGenome != null) {
                uniqueGenome.removeTempFileFromDisk();
            }
        }
    }
}

//minMissingQCFilter1
//inheritanceModelFilter2
//denovoModelFilter3 
//somaticModelFilter4
//assSVHF
//varaintDBHardFilterFiles5 
//varaintDBFilterFiles6
//geneDBFilter7
//
//dbNSFPAnnot8
//dbNSFPPred9
//
//assGVF10
//
//assG11
//assV12
//assPPIG13
//assPPIV14
//assPWG15
//assPWV16
//
//assIBS17d1
//assHRC17d2
//
//assGIS17d3
//assGOS17d4
//
//asIBD17d5
//dbScSNV18
//doubleHitGeneModelFilter19
//
//assGene20
//assVariant20
//
//assOmimGene21
//assOmimVar21
//
//assSDA22
//assSDF22
//
//assDGV23

